if ( TRACE ) { TRACE( JSON.parse( '["AnimatorEventReceiver#Hold","AnimatorEventReceiver#SpawnBullet","AnimatorEventReceiver#PlaySoundBulidMagic","Apartment#OnTriggerEnter","AutoDestroy#init","AutoDestroy#OnEnable","AutoDestroy#Update","AutoDestroy#OnDestroy","AutoDestroy#OnDisable","AutoDestructor#init","AutoDestructor#OnEnable","AutoDestructor#AutoDestroy","AutoDestructor#OnDisable","BaseGun#init","BaseGun#Preparing","BaseGun#Update","BaseGun#LoadBullet","BaseGun#Fire","BaseGun#ExploreFx","BaseGun#OnDisable","Boxophobic.StyledGUI.StyledBanner#$ctor3","Boxophobic.StyledGUI.StyledBanner#$ctor4","Boxophobic.StyledGUI.StyledBanner#ctor","Boxophobic.StyledGUI.StyledBanner#$ctor1","Boxophobic.StyledGUI.StyledBanner#$ctor5","Boxophobic.StyledGUI.StyledBanner#$ctor2","Boxophobic.StyledGUI.StyledButton#init","Boxophobic.StyledGUI.StyledButton#ctor","Boxophobic.StyledGUI.StyledButton#$ctor1","Boxophobic.StyledGUI.StyledCategory#ctor","Boxophobic.StyledGUI.StyledCategory#$ctor1","Boxophobic.StyledGUI.StyledCategory#$ctor3","Boxophobic.StyledGUI.StyledCategory#$ctor2","Boxophobic.StyledGUI.StyledEnum#init","Boxophobic.StyledGUI.StyledEnum#ctor","Boxophobic.StyledGUI.StyledEnum#$ctor1","Boxophobic.StyledGUI.StyledIndent#ctor","Boxophobic.StyledGUI.StyledInteractive#ctor","Boxophobic.StyledGUI.StyledLayers#init","Boxophobic.StyledGUI.StyledLayers#ctor","Boxophobic.StyledGUI.StyledLayers#$ctor1","Boxophobic.StyledGUI.StyledMask#init","Boxophobic.StyledGUI.StyledMask#ctor","Boxophobic.StyledGUI.StyledMask#$ctor1","Boxophobic.StyledGUI.StyledMessage#ctor","Boxophobic.StyledGUI.StyledMessage#$ctor1","Boxophobic.StyledGUI.StyledRangeOptions#ctor","Boxophobic.StyledGUI.StyledSpace#ctor","Boxophobic.StyledGUI.StyledText#init","Boxophobic.StyledGUI.StyledText#ctor","Boxophobic.StyledGUI.StyledText#$ctor1","Boxophobic.StyledGUI.StyledText#$ctor2","Boxophobic.StyledGUI.StyledTexturePreview#init","Boxophobic.StyledGUI.StyledTexturePreview#ctor","Boxophobic.StyledGUI.StyledTexturePreview#$ctor1","Boxophobic.Utils.SettingsData#init","Brick#Start","Brick#OnCollisionEnter","BrokenBuilding#init","BrokenBuilding#CheckBrickListHit","BrokenBuilding#OnEnable","BrokenBuilding#BreakingBrick","BrokenBuilding#ScaleBrick","BulletCameraController#init","BulletCameraController#OnEnable","BulletCameraController#CalculateTime","BulletRotation#Update","CutoutMask#materialForRendering#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","EGA_Laser#init","EGA_Laser#OnEnable","EGA_Laser#Start","EGA_Laser#Update","EGA_Laser#DisablePrepare","EnemyScript#init","EnemyScript#Start","EnemyScript#OnTriggerEnter","EnemyScript#Die","EnemyScript#setRagDoll","EnemyScript#enableRagDoll","EnemyScript#dieee","SingletonMono$1#init","SingletonMono$1#Awake","IECControl#Start","IECControl#Update","MagicHand#OnScoped","MagicHand#Shoot","MagicHand#spawnMagic","MagicHand#SpawnMagicBullet","PlayerController#ClampAngle","PlayerController#init","PlayerController#OnPointerDown","PlayerController#OnDrag","PlayerController#OnPointerUp","PlayerController#OnScoped","PlayerController#OnUnscoped","PlayerController#Shooting","PlayerControllerHand#ClampAngle","PlayerControllerHand#init","PlayerControllerHand#Update","PlayerControllerHand#OnScoped","PlayerControllerHand#OnDrag","PlayerControllerHand#OnPointerUp","PlayerControllerHand#OnPointerDown","Scope#OnEnable","Scope#OnDisable","SingletonWithouMono$1#Instance#get","SingletonWithouMono$1#init","SingletonWithouMono$1#init","SingletonWithouMono$1#Initialize","SingletonWithouMono$1#Preload","SoundManager#playgunshot","SoundManager#playgunreload","SoundManager#playgunhitted","SpawnAttackPos#Update","Singleton$1#Instance#get","NormalBullet#init","NormalBullet#Start","NormalBullet#Init","NormalBullet#OnCollisionEnter","NormalBullet#OnTriggerEnter","NormalBullet#CheckSlowDieLastShot","NormalGun#Fire","GameManager1#inherits","GameManager1#init","GameManager1#checkForVictory","GameManager1#Win","GameManager1#Start","GameManager1#Update","GameManager1#changeCamEndGameLose","GameManager2#inherits","GameManager2#init","GameManager2#checkForVictory","GameManager2#Win","GameManager2#Start","GameManager2#Update","GameManager2#changeCamEndGameLose","GlobalInstance#inherits","GlobalInstance#init","SingletonDontDestroyOnLoad$1#Awake"]' ) ); }
/**
 * @version 1.0.8381.28224
 * @copyright anton
 * @compiler Bridge.NET 17.9.13-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AnimatorEventReceiver start.*/
    Bridge.define("AnimatorEventReceiver", {
        inherits: [UnityEngine.MonoBehaviour],
        events: {
            HoldMagic: null,
            ShootMagic: null,
            BuildMagic: null
        },
        methods: {
            /*AnimatorEventReceiver.Hold start.*/
            Hold: function () {
if ( TRACE ) { TRACE( "AnimatorEventReceiver#Hold", this ); }

                if (!Bridge.staticEquals(this.HoldMagic, null)) {
                    this.HoldMagic(); //thi thuc hien
                }
            },
            /*AnimatorEventReceiver.Hold end.*/

            /*AnimatorEventReceiver.SpawnBullet start.*/
            SpawnBullet: function () {
if ( TRACE ) { TRACE( "AnimatorEventReceiver#SpawnBullet", this ); }

                if (!Bridge.staticEquals(this.ShootMagic, null)) {
                    this.ShootMagic();
                }
            },
            /*AnimatorEventReceiver.SpawnBullet end.*/

            /*AnimatorEventReceiver.PlaySoundBulidMagic start.*/
            PlaySoundBulidMagic: function () {
if ( TRACE ) { TRACE( "AnimatorEventReceiver#PlaySoundBulidMagic", this ); }

                if (!Bridge.staticEquals(this.BuildMagic, null)) {
                    this.BuildMagic();
                }
            },
            /*AnimatorEventReceiver.PlaySoundBulidMagic end.*/


        }
    });
    /*AnimatorEventReceiver end.*/

    /*Apartment start.*/
    Bridge.define("Apartment", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            buildCam: null
        },
        methods: {
            /*Apartment.OnTriggerEnter start.*/
            OnTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "Apartment#OnTriggerEnter", this ); }

                if (Bridge.referenceEquals(other.tag, "Enemy")) {
                    this.gameObject.SetActive(false);
                    this.transform.parent.GetChild(1).gameObject.SetActive(true);
                    Singleton$1(GlobalInstance).Instance.gameManagerInstance.changeCamEndGameLose(this.buildCam);

                }
            },
            /*Apartment.OnTriggerEnter end.*/


        }
    });
    /*Apartment end.*/

    /*AutoDestroy start.*/
    Bridge.define("AutoDestroy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeOut: 0,
            typeDestroy: 0,
            timeStart: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoDestroy#init", this ); }

                this.timeOut = 0.5;
                this.typeDestroy = TypeDestroy.DISABLE;
            }
        },
        methods: {
            /*AutoDestroy.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnEnable", this ); }

                this.timeStart = UnityEngine.Time.time;
            },
            /*AutoDestroy.OnEnable end.*/

            /*AutoDestroy.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "AutoDestroy#Update", this ); }

                if (UnityEngine.Time.time - this.timeStart > this.timeOut) {
                    this.OnDestroy();
                }
            },
            /*AutoDestroy.Update end.*/

            /*AutoDestroy.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnDestroy", this ); }

                if (this.typeDestroy === TypeDestroy.DISABLE) {
                    this.gameObject.SetActive(false);
                } else {
                    if (this.typeDestroy === TypeDestroy.DESTROY) {
                        UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    }
                }
            },
            /*AutoDestroy.OnDestroy end.*/

            /*AutoDestroy.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnDisable", this ); }

                this.OnDestroy();
            },
            /*AutoDestroy.OnDisable end.*/


        }
    });
    /*AutoDestroy end.*/

    /*AutoDestructor start.*/
    Bridge.define("AutoDestructor", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeDestroy: 0,
            isPutToPool: false,
            typeDestroy: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoDestructor#init", this ); }

                this.timeDestroy = 1.5;
                this.isPutToPool = true;
            }
        },
        methods: {
            /*AutoDestructor.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "AutoDestructor#OnEnable", this ); }

                this.Invoke("AutoDestroy", this.timeDestroy);
            },
            /*AutoDestructor.OnEnable end.*/

            /*AutoDestructor.AutoDestroy start.*/
            AutoDestroy: function () {
if ( TRACE ) { TRACE( "AutoDestructor#AutoDestroy", this ); }

                if (this.isPutToPool) {
                    //SimplePool.Despawn(gameObject);
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                } else {
                    switch (this.typeDestroy) {
                        case AutoDestructor.TypeDestroy.Disable: 
                            this.gameObject.SetActive(false);
                            break;
                        case AutoDestructor.TypeDestroy.PutToPool: 
                            this.gameObject.GetComponent(UnityEngine.ParticleSystem).Stop();
                            //SimplePool.Despawn(gameObject);
                            UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                            break;
                        case AutoDestructor.TypeDestroy.Destroy: 
                        default: 
                            UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                            break;
                    }

                }
            },
            /*AutoDestructor.AutoDestroy end.*/

            /*AutoDestructor.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "AutoDestructor#OnDisable", this ); }

                this.CancelInvoke();
            },
            /*AutoDestructor.OnDisable end.*/


        }
    });
    /*AutoDestructor end.*/

    /*AutoDestructor+TypeDestroy start.*/
    Bridge.define("AutoDestructor.TypeDestroy", {
        $kind: "nested enum",
        statics: {
            fields: {
                Disable: 0,
                PutToPool: 1,
                Destroy: 2
            }
        }
    });
    /*AutoDestructor+TypeDestroy end.*/

    /*BaseBullet start.*/
    Bridge.define("BaseBullet", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bloodFx: null,
            exploreFx: null,
            BulletRigid: null,
            DamageForce: 0,
            Damage: 0
        }
    });
    /*BaseBullet end.*/

    /*BaseGun start.*/
    Bridge.define("BaseGun", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            loadBulletPos: null,
            loadBulletRot: null,
            fireFxTrans: null,
            fireFx: null,
            bullet: null,
            bulletObj: null,
            IsEnemy: false,
            bulletRigid: null,
            hit: null,
            main: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BaseGun#init", this ); }

                this.loadBulletPos = new UnityEngine.Vector3();
                this.loadBulletRot = new UnityEngine.Vector3();
                this.hit = new UnityEngine.RaycastHit();
                this.IsEnemy = false;
            }
        },
        methods: {
            /*BaseGun.Preparing start.*/
            Preparing: function () {
if ( TRACE ) { TRACE( "BaseGun#Preparing", this ); }

                UnityEngine.Debug.Log$1("|AAAAA");
                Singleton$1(GlobalInstance).Instance.gameManagerInstance.IsShooting = false;
                Singleton$1(GlobalInstance).Instance.gameManagerInstance.soundfx.playgunreload();
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMove(this.gameObject.transform, this.loadBulletPos.$clone(), 0.3), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.gameObject.transform, new pc.Vec3( 0.0, 0.0, 0.0 ), 0.2), Bridge.fn.bind(this, function () {
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMove(this.gameObject.transform, new pc.Vec3( 1.0, -2.5, 1.4 ), 0.3), DG.Tweening.Ease.OutExpo), function () {
                            Singleton$1(GlobalInstance).Instance.gameManagerInstance.player.IsInteractive = true;
                        });
                    }));
                }));
            },
            /*BaseGun.Preparing end.*/

            /*BaseGun.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "BaseGun#Update", this ); }

                //GlobalInstance.Instance.gameManagerInstance.player.IsInteractive = true;
            },
            /*BaseGun.Update end.*/

            /*BaseGun.LoadBullet start.*/
            LoadBullet: function () {
if ( TRACE ) { TRACE( "BaseGun#LoadBullet", this ); }

                var normalBullet = this.bullet.gameObject.GetComponent(NormalBullet);
                //if(normalBullet != null)
                //{
                //    bullet.Damage = 10;
                //}
                this.bulletObj = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.bullet.gameObject, this.main.transform.position.$clone(), this.main.transform.rotation.$clone());

            },
            /*BaseGun.LoadBullet end.*/

            /*BaseGun.Fire start.*/
            Fire: function () {
if ( TRACE ) { TRACE( "BaseGun#Fire", this ); }

                this.LoadBullet();
                Singleton$1(GlobalInstance).Instance.gameManagerInstance.soundfx.playgunshot();
            },
            /*BaseGun.Fire end.*/

            /*BaseGun.ExploreFx start.*/
            ExploreFx: function () {
if ( TRACE ) { TRACE( "BaseGun#ExploreFx", this ); }

                this.fireFx.Play();
            },
            /*BaseGun.ExploreFx end.*/

            /*BaseGun.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "BaseGun#OnDisable", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.gameObject.transform);
            },
            /*BaseGun.OnDisable end.*/


        }
    });
    /*BaseGun end.*/

    /*Boxophobic.StyledGUI.StyledBanner start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledBanner", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            colorR: 0,
            colorG: 0,
            colorB: 0,
            title: null,
            helpURL: null
        },
        ctors: {
            $ctor3: function (title) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#$ctor3", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = -1;
                this.title = title;
                this.helpURL = "";
            },
            $ctor4: function (title, helpURL) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#$ctor4", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = -1;
                this.title = title;
                this.helpURL = helpURL;
            },
            ctor: function (colorR, colorG, colorB, title) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = colorR;
                this.colorG = colorG;
                this.colorB = colorB;
                this.title = title;
                this.helpURL = "";
            },
            $ctor1: function (colorR, colorG, colorB, title, helpURL) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = colorR;
                this.colorG = colorG;
                this.colorB = colorB;
                this.title = title;
                this.helpURL = helpURL;
            },
            $ctor5: function (title, subtitle, helpURL) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#$ctor5", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = -1;
                this.title = title;
                this.helpURL = helpURL;
            },
            $ctor2: function (colorR, colorG, colorB, title, subtitle, helpURL) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledBanner#$ctor2", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.colorR = colorR;
                this.colorG = colorG;
                this.colorB = colorB;
                this.title = title;
                this.helpURL = helpURL;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledBanner end.*/

    /*Boxophobic.StyledGUI.StyledButton start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledButton", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            text: null,
            top: 0,
            down: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledButton#init", this ); }

                this.text = "";
                this.top = 0;
                this.down = 0;
            },
            ctor: function (Text) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledButton#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.text = Text;
                this.top = 0;
                this.down = 0;
            },
            $ctor1: function (Text, Top, Down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledButton#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.text = Text;
                this.top = Top;
                this.down = Down;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledButton end.*/

    /*Boxophobic.StyledGUI.StyledCategory start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledCategory", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            category: null,
            top: 0,
            down: 0,
            colapsable: false
        },
        ctors: {
            ctor: function (category) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledCategory#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.category = category;
                this.top = 10;
                this.down = 10;
                this.colapsable = false;
            },
            $ctor1: function (category, colapsable) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledCategory#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.category = category;
                this.top = 10;
                this.down = 10;
                this.colapsable = colapsable;
            },
            $ctor3: function (category, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledCategory#$ctor3", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.category = category;
                this.top = top;
                this.down = down;
                this.colapsable = false;
            },
            $ctor2: function (category, top, down, colapsable) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledCategory#$ctor2", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.category = category;
                this.top = top;
                this.down = down;
                this.colapsable = colapsable;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledCategory end.*/

    /*Boxophobic.StyledGUI.StyledEnum start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledEnum", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            display: null,
            file: null,
            options: null,
            top: 0,
            down: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledEnum#init", this ); }

                this.display = "";
                this.file = "";
                this.options = "";
                this.top = 0;
                this.down = 0;
            },
            ctor: function (file, options, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledEnum#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.file = file;
                this.options = options;

                this.top = top;
                this.down = down;
            },
            $ctor1: function (display, file, options, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledEnum#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.display = display;
                this.file = file;
                this.options = options;

                this.top = top;
                this.down = down;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledEnum end.*/

    /*Boxophobic.StyledGUI.StyledIndent start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledIndent", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            indent: 0
        },
        ctors: {
            ctor: function (indent) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledIndent#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.indent = indent;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledIndent end.*/

    /*Boxophobic.StyledGUI.StyledInteractive start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledInteractive", {
        inherits: [UnityEngine.PropertyAttribute],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledInteractive#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);

            }
        }
    });
    /*Boxophobic.StyledGUI.StyledInteractive end.*/

    /*Boxophobic.StyledGUI.StyledLayers start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledLayers", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            display: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledLayers#init", this ); }

                this.display = "";
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledLayers#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
            },
            $ctor1: function (display) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledLayers#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.display = display;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledLayers end.*/

    /*Boxophobic.StyledGUI.StyledMask start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledMask", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            display: null,
            file: null,
            options: null,
            top: 0,
            down: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledMask#init", this ); }

                this.display = "";
                this.file = "";
                this.options = "";
                this.top = 0;
                this.down = 0;
            },
            ctor: function (file, options, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledMask#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.file = file;
                this.options = options;

                this.top = top;
                this.down = down;
            },
            $ctor1: function (display, file, options, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledMask#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.display = display;
                this.file = file;
                this.options = options;

                this.top = top;
                this.down = down;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledMask end.*/

    /*Boxophobic.StyledGUI.StyledMessage start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledMessage", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            type: null,
            message: null,
            top: 0,
            down: 0
        },
        ctors: {
            ctor: function (Type, Message) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledMessage#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.type = Type;
                this.message = Message;
                this.top = 0;
                this.down = 0;
            },
            $ctor1: function (Type, Message, Top, Down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledMessage#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.type = Type;
                this.message = Message;
                this.top = Top;
                this.down = Down;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledMessage end.*/

    /*Boxophobic.StyledGUI.StyledRangeOptions start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledRangeOptions", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            display: null,
            min: 0,
            max: 0,
            options: null
        },
        ctors: {
            ctor: function (display, min, max, options) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledRangeOptions#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.display = display;
                this.min = min;
                this.max = max;

                this.options = options;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledRangeOptions end.*/

    /*Boxophobic.StyledGUI.StyledSpace start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledSpace", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            space: 0
        },
        ctors: {
            ctor: function (space) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledSpace#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.space = space;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledSpace end.*/

    /*Boxophobic.StyledGUI.StyledText start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledText", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            text: null,
            alignment: 0,
            top: 0,
            down: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledText#init", this ); }

                this.text = "";
                this.alignment = UnityEngine.TextAnchor.MiddleCenter;
                this.top = 0;
                this.down = 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledText#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);

            },
            $ctor1: function (alignment) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledText#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.alignment = alignment;
            },
            $ctor2: function (alignment, top, down) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledText#$ctor2", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.alignment = alignment;
                this.top = top;
                this.down = down;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledText end.*/

    /*Boxophobic.StyledGUI.StyledTexturePreview start.*/
    Bridge.define("Boxophobic.StyledGUI.StyledTexturePreview", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            displayName: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledTexturePreview#init", this ); }

                this.displayName = "";
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledTexturePreview#ctor", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.displayName = "";
            },
            $ctor1: function (displayName) {
if ( TRACE ) { TRACE( "Boxophobic.StyledGUI.StyledTexturePreview#$ctor1", this ); }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.displayName = displayName;
            }
        }
    });
    /*Boxophobic.StyledGUI.StyledTexturePreview end.*/

    /*Boxophobic.Utils.SettingsData start.*/
    Bridge.define("Boxophobic.Utils.SettingsData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            data: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Boxophobic.Utils.SettingsData#init", this ); }

                this.data = "";
            }
        }
    });
    /*Boxophobic.Utils.SettingsData end.*/

    /*Brick start.*/
    Bridge.define("Brick", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            BrickRigid: null
        },
        methods: {
            /*Brick.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Brick#Start", this ); }

                this.BrickRigid = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Brick.Start end.*/

            /*Brick.OnCollisionEnter start.*/
            OnCollisionEnter: function (collision) {
if ( TRACE ) { TRACE( "Brick#OnCollisionEnter", this ); }

                this.transform.root.GetChild(0).gameObject.SetActive(false);
                if (collision.gameObject.layer === 14) {
                    this.BrickRigid.isKinematic = false;
                    DG.Tweening.TweenSettingsExtensions.AppendCallback(DG.Tweening.TweenSettingsExtensions.AppendInterval(DG.Tweening.DOTween.Sequence(), 0.7), Bridge.fn.bind(this, function () {
                        var scaleRatio = UnityEngine.Random.Range$1(0.01, 0.08);
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.gameObject.transform, new pc.Vec3( scaleRatio, scaleRatio, scaleRatio ), 1.0), Bridge.fn.bind(this, function () {
                            this.gameObject.SetActive(false);
                        }));
                    }));
                }

                if (collision.gameObject.layer === 12) {
                    this.gameObject.SetActive(false);
                }
            },
            /*Brick.OnCollisionEnter end.*/


        }
    });
    /*Brick end.*/

    /*BrokenBuilding start.*/
    Bridge.define("BrokenBuilding", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            brickList1: null,
            brickList2: null,
            brickList3: null,
            brickList4: null,
            brickList5: null,
            IsBreakAll: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BrokenBuilding#init", this ); }

                this.IsBreakAll = false;
            }
        },
        methods: {
            /*BrokenBuilding.CheckBrickListHit start.*/
            CheckBrickListHit: function (nameBrick, explodedForce) {
if ( TRACE ) { TRACE( "BrokenBuilding#CheckBrickListHit", this ); }

                this.BreakingBrick(this.brickList1, nameBrick, explodedForce);
                this.BreakingBrick(this.brickList2, nameBrick, explodedForce);
                this.BreakingBrick(this.brickList3, nameBrick, explodedForce);
                this.BreakingBrick(this.brickList4, nameBrick, explodedForce);
                this.BreakingBrick(this.brickList5, nameBrick, explodedForce);
                return;
            },
            /*BrokenBuilding.CheckBrickListHit end.*/

            /*BrokenBuilding.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "BrokenBuilding#OnEnable", this ); }

                this.BreakingBrick(this.brickList1, "A", 50);
                this.BreakingBrick(this.brickList2, "A", 78);
                this.BreakingBrick(this.brickList3, "A", 55);
                this.BreakingBrick(this.brickList4, "A", 70);
                this.BreakingBrick(this.brickList5, "A", 60);


            },
            /*BrokenBuilding.OnEnable end.*/

            /*BrokenBuilding.BreakingBrick start.*/
            BreakingBrick: function (brickList, nameBrick, force) {
if ( TRACE ) { TRACE( "BrokenBuilding#BreakingBrick", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(brickList);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        //if (item.transform.name == nameBrick || IsBreakAll)
                        {
                            $t1 = Bridge.getEnumerator(brickList);
                            try {
                                while ($t1.moveNext()) {
                                    var brick = $t1.Current;
                                    //Debug.Log(brick.BrickRigid + " " + brick.transform.name + " " + brick.transform.root.name);
                                    brick.BrickRigid = brick.GetComponent(UnityEngine.Rigidbody);
                                    brick.BrickRigid.isKinematic = false;
                                    brick.BrickRigid.AddExplosionForce(UnityEngine.Random.Range$1(force, force + 10.0), item.transform.position, UnityEngine.Random.Range$1(1, 3.0), UnityEngine.Random.Range$1(1, 2.0), UnityEngine.ForceMode.VelocityChange);
                                    brick.BrickRigid.AddTorque$1(pc.Vec3.RIGHT.clone().clone().scale( 30.0 ), UnityEngine.ForceMode.VelocityChange);

                                    var random = UnityEngine.Random.Range(1, 3);
                                    this.ScaleBrick(brick, random);
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*BrokenBuilding.BreakingBrick end.*/

            /*BrokenBuilding.ScaleBrick start.*/
            ScaleBrick: function (brick, randomDelay) {
if ( TRACE ) { TRACE( "BrokenBuilding#ScaleBrick", this ); }

                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(brick.gameObject.transform, new pc.Vec3( 0.08, 0.08, 0.08 ), 1.0), randomDelay), function () {
                    brick.gameObject.SetActive(false);
                });
            },
            /*BrokenBuilding.ScaleBrick end.*/


        }
    });
    /*BrokenBuilding end.*/

    /*BulletCameraController start.*/
    Bridge.define("BulletCameraController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bulletCam: null,
            _camMoveTarget: null,
            _camRotationTarget: null,
            moveTime: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BulletCameraController#init", this ); }

                this._camMoveTarget = new UnityEngine.Vector3();
                this._camRotationTarget = new UnityEngine.Vector3();
                this._camMoveTarget = new pc.Vec3( -17.0, 0, 10.0 );
                this._camRotationTarget = new pc.Vec3( -1.0, 111.0, 1.0 );
            }
        },
        methods: {
            /*BulletCameraController.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "BulletCameraController#OnEnable", this ); }

                this.CalculateTime();

                DG.Tweening.ShortcutExtensions.DOLocalMove(this.bulletCam.transform, this._camMoveTarget.$clone(), this.moveTime);
                DG.Tweening.ShortcutExtensions.DOLocalRotate(this.bulletCam.transform, this._camRotationTarget.$clone(), this.moveTime);
            },
            /*BulletCameraController.OnEnable end.*/

            /*BulletCameraController.CalculateTime start.*/
            CalculateTime: function () {
if ( TRACE ) { TRACE( "BulletCameraController#CalculateTime", this ); }

                var moveDistance = this._camMoveTarget.$clone().sub( this.bulletCam.transform.localPosition );
                var rotationDistance = this._camRotationTarget.$clone().sub( this.bulletCam.transform.localEulerAngles );

                this.moveTime = moveDistance.length() / 200.0;
            },
            /*BulletCameraController.CalculateTime end.*/


        }
    });
    /*BulletCameraController end.*/

    /*BulletRotation start.*/
    Bridge.define("BulletRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*BulletRotation.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "BulletRotation#Update", this ); }

                this.transform.Rotate(0, -(10000.0 * UnityEngine.Time.deltaTime), 0);
            },
            /*BulletRotation.Update end.*/


        }
    });
    /*BulletRotation end.*/

    /*CutoutMask start.*/
    Bridge.define("CutoutMask", {
        inherits: [UnityEngine.UI.Image],
        props: {
            materialForRendering: {
                get: function () {
if ( TRACE ) { TRACE( "CutoutMask#materialForRendering#get", this ); }

                    var material = new UnityEngine.Material.$ctor1(Bridge.ensureBaseProperty(this, "materialForRendering").$UnityEngine$UI$Graphic$materialForRendering);
                    material.SetInt$1("_StencilComp", UnityEngine.Rendering.CompareFunction.NotEqual);
                    return material;
                }
            }
        }
    });
    /*CutoutMask end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path) or CatmullRom (curved CatmullRom path)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path) or CatmullRom (curved CatmullRom path)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos.$clone());
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Gradient}          gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       strength      The shake strength
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {UnityEngine.Vector2}          strength      The shake strength on each axis
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: "nested class",
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position.$clone());
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color.$clone());
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has reached the given position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP ► TextMesh Pro
     - DOTWEEN_TK2D ► 2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: "nested class",
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t;
                    var rBody = tweenRigidbody ? target.GetComponent(UnityEngine.Rigidbody) : null;
                    if (tweenRigidbody && UnityEngine.Component.op_Inequality(rBody, null)) {
                        t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                    } else {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*EGA_Laser start.*/
    Bridge.define("EGA_Laser", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            HitEffect: null,
            HitOffset: 0,
            MaxLength: 0,
            Laser: null,
            MainTextureLength: 0,
            NoiseTextureLength: 0,
            Length: null,
            LaserSaver: false,
            UpdateSaver: false,
            _mainCam: null,
            Effects: null,
            Hit: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EGA_Laser#init", this ); }

                this.Length = new UnityEngine.Vector4();
                this.HitOffset = 0;
                this.MainTextureLength = 1.0;
                this.NoiseTextureLength = 1.0;
                this.Length = new pc.Vec4( 1, 1, 1, 1 );
                this.LaserSaver = false;
                this.UpdateSaver = false;
            }
        },
        methods: {
            /*EGA_Laser.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "EGA_Laser#OnEnable", this ); }

                this.Laser = this.GetComponent(UnityEngine.LineRenderer);
                this.Laser.SetPosition(0, pc.Vec3.ZERO.clone());
                this.Laser.SetPosition(1, pc.Vec3.ZERO.clone());
            },
            /*EGA_Laser.OnEnable end.*/

            /*EGA_Laser.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EGA_Laser#Start", this ); }

                this._mainCam = UnityEngine.Camera.main;
                this.Effects = this.GetComponentsInChildren(UnityEngine.ParticleSystem);
                this.Hit = this.HitEffect.GetComponentsInChildren(UnityEngine.ParticleSystem);
            },
            /*EGA_Laser.Start end.*/

            /*EGA_Laser.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "EGA_Laser#Update", this ); }

                var $t, $t1;
                //if (Laser.material.HasProperty("_SpeedMainTexUVNoiseZW")) Laser.material.SetVector("_SpeedMainTexUVNoiseZW", LaserSpeed);
                //SetVector("_TilingMainTexUVNoiseZW", Length); - old code, _TilingMainTexUVNoiseZW no more exist
                this.Laser.material.SetTextureScale$1("_MainTex", new pc.Vec2( this.Length.getitem(0), this.Length.getitem(1) ));
                this.Laser.material.SetTextureScale$1("_Noise", new pc.Vec2( this.Length.getitem(2), this.Length.getitem(3) ));
                //To set LineRender position
                if (UnityEngine.Component.op_Inequality(this.Laser, null) && this.UpdateSaver === false) {
                    this.Laser.SetPosition(0, this.transform.position.$clone());
                    var hit = { v : new UnityEngine.RaycastHit() }; //DELATE THIS IF YOU WANT USE LASERS IN 2D
                    //ADD THIS IF YOU WANNT TO USE LASERS IN 2D: RaycastHit2D hit = Physics2D.Raycast(transform.position, transform.forward, MaxLength);       
                    if (UnityEngine.Physics.Raycast$3(this.transform.position, this.transform.TransformDirection(new pc.Vec3( 0, 0, 1 )), hit, this.MaxLength)) {
                        //End laser position if collides with object
                        if (Bridge.referenceEquals(hit.v.transform.tag, "Enemy")) {
                            hit.v.transform.GetComponent(EnemyScript).Die();
                        }
                        this.Laser.SetPosition(1, hit.v.point.$clone());
                        this.HitEffect.transform.position = hit.v.point.$clone().add( hit.v.normal.$clone().clone().scale( this.HitOffset ) );
                        //Hit effect zero rotation
                        this.HitEffect.transform.rotation = pc.Quat.IDENTITY.clone();
                        $t = Bridge.getEnumerator(this.Effects);
                        try {
                            while ($t.moveNext()) {
                                var AllPs = $t.Current;
                                if (!AllPs.isPlaying) {
                                    AllPs.Play();
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        //Texture tiling
                        this.Length.setitem(0, this.MainTextureLength * (pc.Vec3.distance( this.transform.position, hit.v.point )));
                        this.Length.setitem(2, this.NoiseTextureLength * (pc.Vec3.distance( this.transform.position, hit.v.point )));
                        //Texture speed balancer {DISABLED AFTER UPDATE}
                        //LaserSpeed[0] = (LaserStartSpeed[0] * 4) / (Vector3.Distance(transform.position, hit.point));
                        //LaserSpeed[2] = (LaserStartSpeed[2] * 4) / (Vector3.Distance(transform.position, hit.point));
                    } else {
                        //End laser position if doesn't collide with object
                        var EndPos = this.transform.position.$clone().add( this._mainCam.transform.forward.$clone().clone().scale( this.MaxLength ) );
                        this.Laser.SetPosition(1, EndPos.$clone());
                        this.HitEffect.transform.position = EndPos.$clone();
                        $t1 = Bridge.getEnumerator(this.Hit);
                        try {
                            while ($t1.moveNext()) {
                                var AllPs1 = $t1.Current;
                                if (AllPs1.isPlaying) {
                                    AllPs1.Stop();
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        //Texture tiling
                        this.Length.setitem(0, this.MainTextureLength * (pc.Vec3.distance( this.transform.position, EndPos )));
                        this.Length.setitem(2, this.NoiseTextureLength * (pc.Vec3.distance( this.transform.position, EndPos )));
                        //LaserSpeed[0] = (LaserStartSpeed[0] * 4) / (Vector3.Distance(transform.position, EndPos)); {DISABLED AFTER UPDATE}
                        //LaserSpeed[2] = (LaserStartSpeed[2] * 4) / (Vector3.Distance(transform.position, EndPos)); {DISABLED AFTER UPDATE}
                    }
                    //Insurance against the appearance of a laser in the center of coordinates!
                    if (this.Laser.enabled === false && this.LaserSaver === false) {
                        this.LaserSaver = true;
                        this.Laser.enabled = true;
                    }
                }
            },
            /*EGA_Laser.Update end.*/

            /*EGA_Laser.DisablePrepare start.*/
            DisablePrepare: function () {
if ( TRACE ) { TRACE( "EGA_Laser#DisablePrepare", this ); }

                var $t;
                if (UnityEngine.Component.op_Inequality(this.Laser, null)) {
                    this.Laser.enabled = false;
                }
                this.UpdateSaver = true;
                //Effects can = null in multiply shooting
                if (this.Effects != null) {
                    $t = Bridge.getEnumerator(this.Effects);
                    try {
                        while ($t.moveNext()) {
                            var AllPs = $t.Current;
                            if (AllPs.isPlaying) {
                                AllPs.Stop();
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*EGA_Laser.DisablePrepare end.*/


        }
    });
    /*EGA_Laser end.*/

    /*EnemyScript start.*/
    Bridge.define("EnemyScript", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bloodfx: null,
            _anim: null,
            destination: null,
            run: null,
            _rigid: null,
            isDead: false,
            maincollider: null,
            bulelttrace: null,
            impact: 0,
            RagDollParts: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EnemyScript#init", this ); }

                this.destination = new UnityEngine.Vector3();
                this.bulelttrace = new UnityEngine.Vector3();
                this.isDead = false;
                this.RagDollParts = new (System.Collections.Generic.List$1(UnityEngine.Collider)).ctor();
            }
        },
        methods: {
            /*EnemyScript.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EnemyScript#Start", this ); }

                this.setRagDoll();
                this.run = DG.Tweening.ShortcutExtensions.DOMove(this.gameObject.transform, this.destination.$clone(), 35.0);
            },
            /*EnemyScript.Start end.*/

            /*EnemyScript.OnTriggerEnter start.*/
            OnTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "EnemyScript#OnTriggerEnter", this ); }

                if (Bridge.referenceEquals(other.gameObject.tag, "Bullet")) {
                    this.bulelttrace = this.transform.position.$clone().sub( other.transform.position );
                    Singleton$1(GlobalInstance).Instance.gameManagerInstance.soundfx.playgunhitted();
                    var location = other.transform.position.$clone();
                    DG.Tweening.TweenExtensions.Kill(this.run);
                    //_rigid.AddForce(new Vector3(0, 200, 200), ForceMode.Impulse);
                    UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.bloodfx, location.$clone(), pc.Quat.IDENTITY.clone());
                    this.StartCoroutine$1(this.dieee());
                }
            },
            /*EnemyScript.OnTriggerEnter end.*/

            /*EnemyScript.Die start.*/
            Die: function () {
if ( TRACE ) { TRACE( "EnemyScript#Die", this ); }

                if (this.isDead) {
                    return;
                }
                this.isDead = true;
                //GlobalInstance.Instance.gameManagerInstance.soundfx.playgunhitted();
                DG.Tweening.TweenExtensions.Kill(this.run);
                //_rigid.AddForce(new Vector3(0, 200, 200), ForceMode.Impulse);
                this._rigid.velocity = pc.Vec3.ZERO.clone();
                this.StartCoroutine$1(this.dieee());
            },
            /*EnemyScript.Die end.*/

            /*EnemyScript.setRagDoll start.*/
            setRagDoll: function () {
if ( TRACE ) { TRACE( "EnemyScript#setRagDoll", this ); }

                var $t;
                var colliders = this.gameObject.GetComponentsInChildren(UnityEngine.Collider);
                $t = Bridge.getEnumerator(colliders);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        if (UnityEngine.GameObject.op_Inequality(c.gameObject, this.gameObject)) {
                            c.isTrigger = true;
                            this.RagDollParts.add(c);
                            c.attachedRigidbody.isKinematic = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

            },
            /*EnemyScript.setRagDoll end.*/

            /*EnemyScript.enableRagDoll start.*/
            enableRagDoll: function () {
if ( TRACE ) { TRACE( "EnemyScript#enableRagDoll", this ); }

                var $t;
                this._rigid.useGravity = false;
                this.maincollider.enabled = false;
                this.gameObject.GetComponent(UnityEngine.Collider).enabled = false;
                this._anim.enabled = false;
                $t = Bridge.getEnumerator(this.RagDollParts);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        c.attachedRigidbody.isKinematic = false;
                        c.isTrigger = false;
                        c.attachedRigidbody.AddRelativeForce$1(this.bulelttrace.$clone().clone().scale( this.impact ), UnityEngine.ForceMode.Impulse);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i = 0; i < this.RagDollParts.Count; i = (i + 1) | 0) {
                    this.RagDollParts.getItem(i).attachedRigidbody.isKinematic = false;
                    this.RagDollParts.getItem(i).isTrigger = false;
                    if (i === 0) {
                        this.RagDollParts.getItem(i).attachedRigidbody.AddRelativeForce$1(this.bulelttrace.$clone().clone().scale( this.impact ), UnityEngine.ForceMode.Impulse);
                    }
                }
            },
            /*EnemyScript.enableRagDoll end.*/

            /*EnemyScript.dieee start.*/
            dieee: function () {
if ( TRACE ) { TRACE( "EnemyScript#dieee", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    Singleton$1(GlobalInstance).Instance.gameManagerInstance.numberofenemy = (Singleton$1(GlobalInstance).Instance.gameManagerInstance.numberofenemy + 1) | 0;
                                        Singleton$1(GlobalInstance).Instance.gameManagerInstance.checkForVictory();

                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.17);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    //_anim.Play("Armature|push_fall");
                                        this.enableRagDoll();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*EnemyScript.dieee end.*/


        }
    });
    /*EnemyScript end.*/

    /*SingletonMono$1 start.*/
    Bridge.define("SingletonMono$1", function (T) { return {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: Bridge.getDefaultValue(T)
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SingletonMono$1#init", this ); }

                    this.instance = Bridge.getDefaultValue(T);
                }
            }
        },
        methods: {
            /*SingletonMono$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SingletonMono$1#Awake", this ); }

                if (Bridge.rValue(SingletonMono$1(T).instance) == null) {
                    SingletonMono$1(T).instance = Bridge.as(this, T);
                } else {
                    if (UnityEngine.Component.op_Inequality(this, Bridge.rValue(SingletonMono$1(T).instance))) {
                        UnityEngine.Debug.LogWarningFormat("[Singleton] Another instance of" + (Bridge.Reflection.getTypeFullName(T) || "") + "is already exist ");
                        UnityEngine.Object.DestroyImmediate(this.gameObject);
                        return;
                    }
                }
            },
            /*SingletonMono$1.Awake end.*/


        }
    }; });
    /*SingletonMono$1 end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*IECControl start.*/
    Bridge.define("IECControl", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*IECControl.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "IECControl#Start", this ); }

                Luna.Unity.LifeCycle.GameStarted();
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*IECControl.Start end.*/

            /*IECControl.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "IECControl#Update", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    Luna.Unity.Playable.InstallFullGame();
                }
            },
            /*IECControl.Update end.*/


        }
    });
    /*IECControl end.*/

    /*MagicHand start.*/
    Bridge.define("MagicHand", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            handAnimator: null,
            magicObj: null,
            magicSpawnPos: null,
            fireFx: null,
            secondFireFx: null
        },
        methods: {
            /*MagicHand.OnScoped start.*/
            OnScoped: function () {
if ( TRACE ) { TRACE( "MagicHand#OnScoped", this ); }

                //isCompared = true;
                this.handAnimator.Play$2("Hold");
                this.fireFx.gameObject.SetActive(true);
                if (UnityEngine.Component.op_Inequality(this.secondFireFx, null)) {
                    this.secondFireFx.gameObject.SetActive(true);
                    this.secondFireFx.Play();
                }
            },
            /*MagicHand.OnScoped end.*/

            /*MagicHand.Shoot start.*/
            Shoot: function () {
if ( TRACE ) { TRACE( "MagicHand#Shoot", this ); }

                this.StartCoroutine$1(this.spawnMagic());
            },
            /*MagicHand.Shoot end.*/

            /*MagicHand.spawnMagic start.*/
            spawnMagic: function () {
if ( TRACE ) { TRACE( "MagicHand#spawnMagic", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.handAnimator.Play$2("Shoot");
                                        this.fireFx.gameObject.SetActive(false);
                                        if (UnityEngine.Component.op_Inequality(this.secondFireFx, null)) {
                                            this.secondFireFx.gameObject.SetActive(false);
                                        }
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.SpawnMagicBullet();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*MagicHand.spawnMagic end.*/

            /*MagicHand.SpawnMagicBullet start.*/
            SpawnMagicBullet: function () {
if ( TRACE ) { TRACE( "MagicHand#SpawnMagicBullet", this ); }

                UnityEngine.Object.Instantiate(UnityEngine.GameObject, this.magicObj, this.magicSpawnPos.transform);
            },
            /*MagicHand.SpawnMagicBullet end.*/


        }
    });
    /*MagicHand end.*/

    /*PlayerController start.*/
    Bridge.define("PlayerController", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerUpHandler],
        statics: {
            methods: {
                /*PlayerController.ClampAngle:static start.*/
                ClampAngle: function (angle, min, max) {
if ( TRACE ) { TRACE( "PlayerController#ClampAngle", this ); }

                    var start = (min + max) * 0.5 - 180;
                    var floor = Bridge.Int.mul(Math.floor((angle - start) / 360), 360);
                    min += floor;
                    max += floor;
                    return Math.max(min, Math.min(angle, max));
                },
                /*PlayerController.ClampAngle:static end.*/


            }
        },
        fields: {
            scopeOverlay: null,
            m_ispointDown: false,
            lastMousePosition: null,
            gunMovingPos: null,
            _FOVscoped: 0,
            leftCamBound: 0,
            upCamBound: 0,
            rightCamBound: 0,
            downCamBound: 0,
            _FOVcache: 0,
            m_isClickPoint: false,
            IsInteractive: false,
            SniperGun: null,
            CanShoot: false,
            m_camera: null,
            IsShooting: false,
            velocity: 0,
            IsShowEnemyPopup: false,
            smoothTime: 0
        },
        alias: [
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PlayerController#init", this ); }

                this.lastMousePosition = new UnityEngine.Vector3();
                this.gunMovingPos = new UnityEngine.Vector3();
                this.IsShooting = false;
                this.velocity = 0.0;
            }
        },
        methods: {
            /*PlayerController.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "PlayerController#OnPointerDown", this ); }

                if (!this.IsInteractive) {
                    return;
                }
                this.m_ispointDown = true;
                this.lastMousePosition = UnityEngine.Input.mousePosition.$clone();
                this.m_ispointDown = false;
                this.OnScoped();
            },
            /*PlayerController.OnPointerDown end.*/

            /*PlayerController.OnDrag start.*/
            OnDrag: function (evenData) {
if ( TRACE ) { TRACE( "PlayerController#OnDrag", this ); }

                if (!this.IsInteractive) {
                    return;
                }
                if (this.m_ispointDown && this.IsInteractive && this.IsShowEnemyPopup === false) {
                    this.OnScoped();
                }

                var delta = UnityEngine.Input.mousePosition.$clone().sub( this.lastMousePosition );
                delta = delta.$clone().scale( 1.0 / ( UnityEngine.Time.deltaTime ) ).clone().scale( UnityEngine.Mathf.SmoothDamp(0, 0.007, Bridge.ref(this, "velocity"), this.smoothTime) );

                this.lastMousePosition = UnityEngine.Input.mousePosition.$clone();

                var relativePos = new pc.Vec3( -delta.y, delta.x, 0 );
                var startRotation = this.m_camera.transform.eulerAngles.$clone();
                var targetRotation = startRotation.$clone().add( relativePos ); //xoay theo delta

                targetRotation.x = PlayerController.ClampAngle(targetRotation.x, this.upCamBound, this.downCamBound);
                targetRotation.y = PlayerController.ClampAngle(targetRotation.y, this.leftCamBound, this.rightCamBound);

                this.m_camera.transform.rotation = new pc.Quat().setFromEulerAngles_Unity( targetRotation.x, targetRotation.y, targetRotation.z );
            },
            /*PlayerController.OnDrag end.*/

            /*PlayerController.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "PlayerController#OnPointerUp", this ); }

                if (this.IsInteractive) {
                    this.m_isClickPoint = false;
                    DG.Tweening.ShortcutExtensions.DOKill(this.SniperGun.gameObject.transform);
                    this.OnUnscoped();
                }
            },
            /*PlayerController.OnPointerUp end.*/

            /*PlayerController.OnScoped start.*/
            OnScoped: function () {
if ( TRACE ) { TRACE( "PlayerController#OnScoped", this ); }

                this.m_isClickPoint = true;
                this.CanShoot = true;
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMove(this.SniperGun.gameObject.transform, this.gunMovingPos.$clone(), 0.2), DG.Tweening.Ease.OutQuart), Bridge.fn.bind(this, function () {
                    this.SniperGun.gameObject.SetActive(false);
                    DG.Tweening.ShortcutExtensions.DOFieldOfView(this.m_camera, this._FOVscoped, 0.1);
                    this.scopeOverlay.gameObject.SetActive(true);
                    DG.Tweening.ShortcutExtensions.DOKill(this.SniperGun.transform);
                }));
            },
            /*PlayerController.OnScoped end.*/

            /*PlayerController.OnUnscoped start.*/
            OnUnscoped: function () {
if ( TRACE ) { TRACE( "PlayerController#OnUnscoped", this ); }

                DG.Tweening.ShortcutExtensions.DOFieldOfView(this.m_camera, this._FOVcache, 0.1);
                DG.Tweening.ShortcutExtensions.DOLocalMove(this.SniperGun.gameObject.transform, new pc.Vec3( 1.0, -2.5, 1.4 ), 0.0);
                this.SniperGun.gameObject.SetActive(true);
                this.scopeOverlay.gameObject.SetActive(false);

                if (this.CanShoot) {
                    this.SniperGun.gameObject.GetComponent(BaseGun).ExploreFx();
                    this.IsInteractive = false;
                    this.CanShoot = false;
                    this.Shooting();
                    this.SniperGun.gameObject.GetComponent(BaseGun).Preparing();
                }
            },
            /*PlayerController.OnUnscoped end.*/

            /*PlayerController.Shooting start.*/
            Shooting: function () {
if ( TRACE ) { TRACE( "PlayerController#Shooting", this ); }

                this.IsShooting = true;

                this.SniperGun.Fire();
            },
            /*PlayerController.Shooting end.*/


        }
    });
    /*PlayerController end.*/

    /*PlayerControllerHand start.*/
    Bridge.define("PlayerControllerHand", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerUpHandler],
        statics: {
            methods: {
                /*PlayerControllerHand.ClampAngle:static start.*/
                ClampAngle: function (angle, min, max) {
if ( TRACE ) { TRACE( "PlayerControllerHand#ClampAngle", this ); }

                    var start = (min + max) * 0.5 - 180;
                    var floor = Bridge.Int.mul(Math.floor((angle - start) / 360), 360);
                    min += floor;
                    max += floor;
                    return Math.max(min, Math.min(angle, max));
                },
                /*PlayerControllerHand.ClampAngle:static end.*/


            }
        },
        fields: {
            leftCamBound: 0,
            upCamBound: 0,
            rightCamBound: 0,
            downCamBound: 0,
            smoothTime: 0,
            lastMousePosition: null,
            IsInteractive: false,
            magichand: null,
            CanShoot: false,
            IsShooting: false,
            velocity: 0,
            m_camera: null,
            m_ispointDown: false,
            m_ispointUp: false,
            IsShowEnemyPopup: false
        },
        alias: [
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PlayerControllerHand#init", this ); }

                this.lastMousePosition = new UnityEngine.Vector3();
                this.velocity = 0.0;
            }
        },
        methods: {
            /*PlayerControllerHand.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "PlayerControllerHand#Update", this ); }

                if (this.m_ispointUp) {
                    if (this.CanShoot) {
                        this.magichand.Shoot();
                    }
                    this.CanShoot = false;
                    this.m_ispointUp = false;
                    this.m_ispointDown = false;
                    return;
                }

                if (this.m_ispointDown && this.IsInteractive) {
                    this.magichand.OnScoped();
                    this.m_ispointDown = false;
                    this.m_ispointUp = false;
                }
            },
            /*PlayerControllerHand.Update end.*/

            /*PlayerControllerHand.OnScoped start.*/
            OnScoped: function () {
if ( TRACE ) { TRACE( "PlayerControllerHand#OnScoped", this ); }

                this.CanShoot = true;
                this.magichand.OnScoped();
            },
            /*PlayerControllerHand.OnScoped end.*/

            /*PlayerControllerHand.OnDrag start.*/
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "PlayerControllerHand#OnDrag", this ); }

                if (!this.IsInteractive) {
                    return;
                }
                if (this.m_ispointDown && this.IsInteractive && this.IsShowEnemyPopup === false) {
                    this.OnScoped();
                }

                var delta = UnityEngine.Input.mousePosition.$clone().sub( this.lastMousePosition );
                delta = delta.$clone().scale( 1.0 / ( UnityEngine.Time.deltaTime ) ).clone().scale( UnityEngine.Mathf.SmoothDamp(0, 0.007, Bridge.ref(this, "velocity"), this.smoothTime) );

                this.lastMousePosition = UnityEngine.Input.mousePosition.$clone();

                var relativePos = new pc.Vec3( -delta.y, delta.x, 0 );
                var startRotation = this.m_camera.transform.eulerAngles.$clone();
                var targetRotation = startRotation.$clone().add( relativePos ); //xoay theo delta

                targetRotation.x = PlayerControllerHand.ClampAngle(targetRotation.x, this.upCamBound, this.downCamBound);
                targetRotation.y = PlayerControllerHand.ClampAngle(targetRotation.y, this.leftCamBound, this.rightCamBound);

                this.m_camera.transform.rotation = new pc.Quat().setFromEulerAngles_Unity( targetRotation.x, targetRotation.y, targetRotation.z );
            },
            /*PlayerControllerHand.OnDrag end.*/

            /*PlayerControllerHand.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "PlayerControllerHand#OnPointerUp", this ); }

                if (this.IsInteractive) {
                    DG.Tweening.ShortcutExtensions.DOKill(this.magichand.transform);
                    if (this.CanShoot) {
                        this.CanShoot = false;
                        this.magichand.Shoot();
                    }
                }
            },
            /*PlayerControllerHand.OnPointerUp end.*/

            /*PlayerControllerHand.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "PlayerControllerHand#OnPointerDown", this ); }

                if (!this.IsInteractive) {
                    return;
                }
                this.m_ispointDown = true;
                this.lastMousePosition = UnityEngine.Input.mousePosition.$clone();
                this.m_ispointDown = false;
                this.OnScoped();
            },
            /*PlayerControllerHand.OnPointerDown end.*/


        }
    });
    /*PlayerControllerHand end.*/

    /*Scope start.*/
    Bridge.define("Scope", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            scopeImgList: null
        },
        methods: {
            /*Scope.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Scope#OnEnable", this ); }

                for (var i = 0; i < this.scopeImgList.Count; i = (i + 1) | 0) {
                    if (i === ((this.scopeImgList.Count - 1) | 0)) {
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$2(this.scopeImgList.getItem(i), 1.0, 0.2), function () {
                            Singleton$1(GlobalInstance).Instance.gameManagerInstance.player.CanShoot = true;
                        });
                    } else {

                        DG.Tweening.DOTweenModuleUI.DOFade$2(this.scopeImgList.getItem(i), 1.0, 0.2);
                        DG.Tweening.DOTweenModuleUI.DOFade$2(this.scopeImgList.getItem(i), 1.0, 0.2);
                    }
                }
            },
            /*Scope.OnEnable end.*/

            /*Scope.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Scope#OnDisable", this ); }

                for (var i = 0; i < this.scopeImgList.Count; i = (i + 1) | 0) {
                    var tempColor = this.scopeImgList.getItem(i).color.$clone();
                    tempColor.a = 0.0;
                    this.scopeImgList.getItem(i).color = tempColor.$clone();

                    DG.Tweening.ShortcutExtensions.DOKill(this.scopeImgList.getItem(i));
                }
            },
            /*Scope.OnDisable end.*/


        }
    });
    /*Scope end.*/

    /*SingletonWithouMono$1 start.*/
    Bridge.define("SingletonWithouMono$1", function (T) { return {
        statics: {
            fields: {
                instance: Bridge.getDefaultValue(T)
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Instance#get", this ); }

                        if (Bridge.rValue(SingletonWithouMono$1(T).instance) != null) {
                            return Bridge.rValue(SingletonWithouMono$1(T).instance);
                        }
                        SingletonWithouMono$1(T).instance = Bridge.createInstance(T);
                        (Bridge.as(Bridge.rValue(SingletonWithouMono$1(T).instance), SingletonWithouMono$1(T))).Initialize();
                        return Bridge.rValue(SingletonWithouMono$1(T).instance);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#init", this ); }

                    this.instance = Bridge.getDefaultValue(T);
                }
            }
        },
        fields: {
            initialized: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#init", this ); }

                this.initialized = false;
            }
        },
        methods: {
            /*SingletonWithouMono$1.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Initialize", this ); }

                if (this.initialized) {
                    return;
                }
                this.initialized = true;
            },
            /*SingletonWithouMono$1.Initialize end.*/

            /*SingletonWithouMono$1.Preload start.*/
            Preload: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Preload", this ); }
 },
            /*SingletonWithouMono$1.Preload end.*/


        }
    }; });
    /*SingletonWithouMono$1 end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reloadfx: null,
            gunfx: null,
            monsterdie: null
        },
        methods: {
            /*SoundManager.playgunshot start.*/
            playgunshot: function () {
if ( TRACE ) { TRACE( "SoundManager#playgunshot", this ); }

                this.gunfx.Play();
            },
            /*SoundManager.playgunshot end.*/

            /*SoundManager.playgunreload start.*/
            playgunreload: function () {
if ( TRACE ) { TRACE( "SoundManager#playgunreload", this ); }

                this.reloadfx.Play();
            },
            /*SoundManager.playgunreload end.*/

            /*SoundManager.playgunhitted start.*/
            playgunhitted: function () {
if ( TRACE ) { TRACE( "SoundManager#playgunhitted", this ); }

                this.monsterdie.Play();
            },
            /*SoundManager.playgunhitted end.*/


        }
    });
    /*SoundManager end.*/

    /*SpawnAttackPos start.*/
    Bridge.define("SpawnAttackPos", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*SpawnAttackPos.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "SpawnAttackPos#Update", this ); }

                //var redHeart = GlobalInstance.Instance.gameManagerInstance.RedHeart;
                //var dir = -(Camera.main.transform.position - redHeart.transform.position);
                //this.transform.rotation = Quaternion.LookRotation(dir);
            },
            /*SpawnAttackPos.Update end.*/


        }
    });
    /*SpawnAttackPos end.*/

    /*StyledMonoBehaviour start.*/
    Bridge.define("StyledMonoBehaviour", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*StyledMonoBehaviour end.*/

    /*StyledScriptableObject start.*/
    Bridge.define("StyledScriptableObject", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*StyledScriptableObject end.*/

    /*TypeDestroy start.*/
    Bridge.define("TypeDestroy", {
        $kind: "enum",
        statics: {
            fields: {
                DISABLE: 0,
                RESPAWNER: 1,
                DESTROY: 2
            }
        }
    });
    /*TypeDestroy end.*/

    /*Singleton$1 start.*/
    Bridge.define("Singleton$1", function (T) { return {
        inherits: [SingletonMono$1(T)],
        statics: {
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Singleton$1#Instance#get", this ); }

                        if (Bridge.rValue(SingletonMono$1(T).instance) != null) {
                            return Bridge.rValue(SingletonMono$1(T).instance);
                        }
                        SingletonMono$1(T).instance = Bridge.cast(UnityEngine.Object.FindObjectOfType$1(T), T);
                        if (Bridge.rValue(SingletonMono$1(T).instance) == null) {
                            UnityEngine.Debug.LogWarningFormat("[Singleton] Class {0} not found! Create empty instance", [T]);
                            SingletonMono$1(T).instance = Bridge.rValue(new UnityEngine.GameObject.$ctor2(Bridge.Reflection.getTypeName(T)).AddComponent(T));
                        }
                        return Bridge.rValue(SingletonMono$1(T).instance);
                    }
                }
            }
        }
    }; });
    /*Singleton$1 end.*/

    /*KameBullet start.*/
    Bridge.define("KameBullet", {
        inherits: [BaseBullet],
        fields: {
            X2Pref: null
        }
    });
    /*KameBullet end.*/

    /*NormalBullet start.*/
    Bridge.define("NormalBullet", {
        inherits: [BaseBullet],
        fields: {
            bulletList: null,
            _isSLow: false,
            cameraMain: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "NormalBullet#init", this ); }

                this._isSLow = false;
            }
        },
        methods: {
            /*NormalBullet.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "NormalBullet#Start", this ); }

                this.Init();
            },
            /*NormalBullet.Start end.*/

            /*NormalBullet.Init start.*/
            Init: function () {
if ( TRACE ) { TRACE( "NormalBullet#Init", this ); }

                this.bulletList.SetActive(true);
            },
            /*NormalBullet.Init end.*/

            /*NormalBullet.OnCollisionEnter start.*/
            OnCollisionEnter: function (collision) {
if ( TRACE ) { TRACE( "NormalBullet#OnCollisionEnter", this ); }

                // PLAY BULLET SOUND
                if ((collision.gameObject.layer === 14 && Singleton$1(GlobalInstance).Instance.gameManagerInstance.SniperGun.GetComponent(BaseGun).IsEnemy === true) || collision.gameObject.layer === 21) {
                    if (collision.gameObject.layer === 14) {
                        //play sound enemy got hit
                    } else {
                        //Something Got Broke Here
                    }
                    var contact = collision.GetContact(0);
                    var rot = new pc.Quat().fromTo( pc.Vec3.UP.clone(), contact.normal );
                    var pos = contact.point.$clone();
                    //BLOOD AND STUFF
                    //var blood = SimplePool.Spawn(bloodFx, pos, rot);

                    //DOTween.Sequence().AppendInterval(1f).AppendCallback(() =>
                    //{
                    //    SimplePool.Despawn(blood.gameObject);
                    //    //SimplePool.Despawn(explore.gameObject);
                    //});
                }
                if (collision.gameObject.layer === 19) {
                    var contact1 = collision.GetContact(0);
                    var build = collision.gameObject.transform.parent.GetComponent(BrokenBuilding);
                    build.CheckBrickListHit(collision.gameObject.transform.name, 20.0);
                    var rot1 = new pc.Quat().fromTo( pc.Vec3.UP.clone(), contact1.normal );
                    var pos1 = contact1.point.$clone();
                    var explore = UnityEngine.Object.Instantiate$2(UnityEngine.ParticleSystem, this.exploreFx, pos1.$clone(), rot1.$clone());
                    DG.Tweening.TweenSettingsExtensions.AppendCallback(DG.Tweening.TweenSettingsExtensions.AppendInterval(DG.Tweening.DOTween.Sequence(), 1.0), function () {
                        UnityEngine.Object.Destroy(explore);
                    });
                }

                this.BulletRigid.velocity = pc.Vec3.ZERO.clone();
                UnityEngine.MonoBehaviour.Destroy(this.gameObject);
            },
            /*NormalBullet.OnCollisionEnter end.*/

            /*NormalBullet.OnTriggerEnter start.*/
            OnTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "NormalBullet#OnTriggerEnter", this ); }

                if (other.gameObject.layer === 14 || other.gameObject.CompareTag("Enemy") || other.gameObject.CompareTag("FlyEnemy")) {
                    //SoundManager.Instance.PlayEnemyCollsionSound(SoundManager.SoundEnenmyType.Injured);
                    this.CheckSlowDieLastShot();
                    //SimplePool.Despawn(this.gameObject);
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }

                if (other.gameObject.layer === 19) {
                    var build = other.gameObject.transform.parent.GetComponent(BrokenBuilding);
                    build.CheckBrickListHit(other.gameObject.transform.name, 20.0);
                    //var explore = SimplePool.Spawn(exploreFx, other.gameObject.transform.position, other.gameObject.transform.rotation);
                    //DOTween.Sequence().AppendInterval(1f).AppendCallback(() =>
                    //{
                    //    SimplePool.Despawn(explore.gameObject);
                    //});
                }
            },
            /*NormalBullet.OnTriggerEnter end.*/

            /*NormalBullet.CheckSlowDieLastShot start.*/
            CheckSlowDieLastShot: function () {
if ( TRACE ) { TRACE( "NormalBullet#CheckSlowDieLastShot", this ); }

                //if (GameManager.Instance.CurrentLevelManager.EnemyAmount == 1)
                //{
                //    foreach (var enemy in GameManager.Instance.CurrentLevelManager.EnenmyInLevelList)
                //    {
                //        if (enemy.HeathPoint <= 0 && enemy.IsDieState == false)
                //        {
                //            GameManager.Instance.PlayerController.SniperGun.bulletObj.GetComponent<NormalBullet>().BulletCam.SetActive(false);
                //            GameManager.Instance.PlayerController.SniperGun.gameObject.SetActive(false);
                //            GameManager.Instance.MainCamera.SetupLastShopCam(GameManager.Instance.CurrentLevelManager.EnenmyInLevelList.IndexOf(enemy));
                //            enemy.CheckToDie();
                //        }
                //    }
                //}
            },
            /*NormalBullet.CheckSlowDieLastShot end.*/


        }
    });
    /*NormalBullet end.*/

    /*NormalGun start.*/
    Bridge.define("NormalGun", {
        inherits: [BaseGun],
        fields: {
            shootForce: 0,
            x2Pref: null
        },
        methods: {
            /*NormalGun.Fire start.*/
            Fire: function () {
if ( TRACE ) { TRACE( "NormalGun#Fire", this ); }

                BaseGun.prototype.Fire.call(this);
                ;
                if (UnityEngine.GameObject.op_Inequality(this.bulletObj, null)) {
                    this.bulletRigid = this.bulletObj.GetComponent(UnityEngine.Rigidbody);
                    this.bulletRigid.velocity = pc.Vec3.ZERO.clone();
                    this.bulletRigid.AddForce$1(this.main.transform.forward.$clone().clone().scale( this.shootForce ), UnityEngine.ForceMode.Impulse);
                    //CheckTargetToTakeDamage();
                    //SoundManager.Instance.PlayShootSoundFx(GunTypeName.Normal);
                }

            },
            /*NormalGun.Fire end.*/


        }
    });
    /*NormalGun end.*/

    /*GameManager1 start.*/
    Bridge.define("GameManager1", {
        inherits: function () {
if ( TRACE ) { TRACE( "GameManager1#inherits", this ); }
 return [Singleton$1(GameManager1)]; },
        fields: {
            IsShooting: false,
            SniperGun: null,
            player: null,
            _mainCam: null,
            canvasshooting: null,
            itsOver: false,
            guide: null,
            soundfx: null,
            eclose: null,
            ecwin: null,
            numberofenemy: 0,
            backgroundFX: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameManager1#init", this ); }

                this.IsShooting = false;
            }
        },
        methods: {
            /*GameManager1.checkForVictory start.*/
            checkForVictory: function () {
if ( TRACE ) { TRACE( "GameManager1#checkForVictory", this ); }

                if (this.numberofenemy === 2) {
                    this.Win();
                }
            },
            /*GameManager1.checkForVictory end.*/

            /*GameManager1.Win start.*/
            Win: function () {
if ( TRACE ) { TRACE( "GameManager1#Win", this ); }

                //ShowEndCasrd
                this.itsOver = true;
                this.SniperGun.gameObject.SetActive(false);
                this.backgroundFX.Stop();
                Luna.Unity.LifeCycle.GameEnded();
                this.ecwin.SetActive(true);
            },
            /*GameManager1.Win end.*/

            /*GameManager1.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager1#Start", this ); }

                this.SniperGun.Preparing();
            },
            /*GameManager1.Start end.*/

            /*GameManager1.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "GameManager1#Update", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    if (this.guide.activeSelf) {
                        this.guide.SetActive(false);
                    }
                    if (this.itsOver) {
                        Luna.Unity.Playable.InstallFullGame();
                    }
                }

            },
            /*GameManager1.Update end.*/

            /*GameManager1.changeCamEndGameLose start.*/
            changeCamEndGameLose: function (a) {
if ( TRACE ) { TRACE( "GameManager1#changeCamEndGameLose", this ); }

                if (this.itsOver) {
                    return;
                }
                this.itsOver = true;
                //_mainCam.gameObject.SetActive(false);
                //a.gameObject.SetActive(true);
                this.canvasshooting.SetActive(false);
                Luna.Unity.LifeCycle.GameEnded();
                this._mainCam.gameObject.transform.position = a.transform.position.$clone();
                this._mainCam.transform.rotation = a.transform.rotation.$clone();
                this.guide.SetActive(false);
                this.SniperGun.gameObject.SetActive(false);
                this.player.enabled = false;
                this.eclose.SetActive(true);
                this.backgroundFX.Stop();
            },
            /*GameManager1.changeCamEndGameLose end.*/


        }
    });
    /*GameManager1 end.*/

    /*GameManager2 start.*/
    Bridge.define("GameManager2", {
        inherits: function () {
if ( TRACE ) { TRACE( "GameManager2#inherits", this ); }
 return [Singleton$1(GameManager2)]; },
        fields: {
            IsShooting: false,
            SniperGun: null,
            player: null,
            _mainCam: null,
            canvasshooting: null,
            RedHeart: null,
            itsOver: false,
            guide: null,
            soundfx: null,
            eclose: null,
            ecwin: null,
            numberofenemy: 0,
            backgroundFX: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameManager2#init", this ); }

                this.IsShooting = false;
                this.numberofenemy = 0;
            }
        },
        methods: {
            /*GameManager2.checkForVictory start.*/
            checkForVictory: function () {
if ( TRACE ) { TRACE( "GameManager2#checkForVictory", this ); }

                if (this.numberofenemy === 2) {
                    this.Win();
                }
            },
            /*GameManager2.checkForVictory end.*/

            /*GameManager2.Win start.*/
            Win: function () {
if ( TRACE ) { TRACE( "GameManager2#Win", this ); }

                //ShowEndCasrd
                this.itsOver = true;
                this.SniperGun.gameObject.SetActive(false);
                this.backgroundFX.Stop();
                Luna.Unity.LifeCycle.GameEnded();
                this.ecwin.SetActive(true);
            },
            /*GameManager2.Win end.*/

            /*GameManager2.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager2#Start", this ); }
 },
            /*GameManager2.Start end.*/

            /*GameManager2.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "GameManager2#Update", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    if (this.guide.activeSelf) {
                        this.guide.SetActive(false);
                    }
                    if (this.itsOver) {
                        Luna.Unity.Playable.InstallFullGame();
                    }
                }

            },
            /*GameManager2.Update end.*/

            /*GameManager2.changeCamEndGameLose start.*/
            changeCamEndGameLose: function (a) {
if ( TRACE ) { TRACE( "GameManager2#changeCamEndGameLose", this ); }

                if (this.itsOver) {
                    return;
                }
                this.itsOver = true;
                this.RedHeart.gameObject.SetActive(false);
                //_mainCam.gameObject.SetActive(false);
                //a.gameObject.SetActive(true);
                //canvasshooting.SetActive(false);
                Luna.Unity.LifeCycle.GameEnded();
                this._mainCam.gameObject.transform.position = a.transform.position.$clone();
                this._mainCam.transform.rotation = a.transform.rotation.$clone();
                this.guide.SetActive(false);
                this.SniperGun.gameObject.SetActive(false);
                this.player.enabled = false;
                this.eclose.SetActive(true);
                this.backgroundFX.Stop();
            },
            /*GameManager2.changeCamEndGameLose end.*/


        }
    });
    /*GameManager2 end.*/

    /*GlobalInstance start.*/
    Bridge.define("GlobalInstance", {
        inherits: function () {
if ( TRACE ) { TRACE( "GlobalInstance#inherits", this ); }
 return [Singleton$1(GlobalInstance)]; },
        fields: {
            gameManagerInstance: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GlobalInstance#init", this ); }

                this.gameManagerInstance = Singleton$1(GameManager1).Instance;
            }
        }
    });
    /*GlobalInstance end.*/

    /*SingletonDontDestroyOnLoad$1 start.*/
    Bridge.define("SingletonDontDestroyOnLoad$1", function (T) { return {
        inherits: [Singleton$1(T)],
        methods: {
            /*SingletonDontDestroyOnLoad$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SingletonDontDestroyOnLoad$1#Awake", this ); }

                UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                Singleton$1(T).prototype.Awake.call(this);
            },
            /*SingletonDontDestroyOnLoad$1.Awake end.*/


        }
    }; });
    /*SingletonDontDestroyOnLoad$1 end.*/

    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","System.Collections.Generic","System.Collections","DG.Tweening","UnityEngine.UI","UnityEngine.EventSystems","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening.Plugins.Core.PathCore","DG.Tweening.Plugins.Options"];

    /*EGA_Laser start.*/
    $m("EGA_Laser", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DisablePrepare","t":8,"sn":"DisablePrepare","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"Effects","t":4,"rt":System.Array.type(UnityEngine.ParticleSystem),"sn":"Effects"},{"a":1,"n":"Hit","t":4,"rt":System.Array.type(UnityEngine.ParticleSystem),"sn":"Hit"},{"a":2,"n":"HitEffect","t":4,"rt":$n[1].GameObject,"sn":"HitEffect"},{"a":2,"n":"HitOffset","t":4,"rt":$n[0].Single,"sn":"HitOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"Laser","t":4,"rt":$n[1].LineRenderer,"sn":"Laser"},{"a":1,"n":"LaserSaver","t":4,"rt":$n[0].Boolean,"sn":"LaserSaver","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"Length","t":4,"rt":$n[1].Vector4,"sn":"Length"},{"a":2,"n":"MainTextureLength","t":4,"rt":$n[0].Single,"sn":"MainTextureLength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"MaxLength","t":4,"rt":$n[0].Single,"sn":"MaxLength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"NoiseTextureLength","t":4,"rt":$n[0].Single,"sn":"NoiseTextureLength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"UpdateSaver","t":4,"rt":$n[0].Boolean,"sn":"UpdateSaver","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_mainCam","t":4,"rt":$n[1].Camera,"sn":"_mainCam"}]}; }, $n);
    /*EGA_Laser end.*/

    /*AutoDestructor start.*/
    $m("AutoDestructor", function () { return {"nested":[AutoDestructor.TypeDestroy],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AutoDestroy","t":8,"sn":"AutoDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPutToPool","t":4,"rt":$n[0].Boolean,"sn":"isPutToPool","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDestroy","t":4,"rt":$n[0].Single,"sn":"timeDestroy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"typeDestroy","t":4,"rt":AutoDestructor.TypeDestroy,"sn":"typeDestroy","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}}]}; }, $n);
    /*AutoDestructor end.*/

    /*AutoDestructor+TypeDestroy start.*/
    $m("AutoDestructor.TypeDestroy", function () { return {"td":AutoDestructor,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Destroy","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"Destroy","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}},{"a":2,"n":"Disable","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"Disable","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}},{"a":2,"n":"PutToPool","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"PutToPool","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}}]}; }, $n);
    /*AutoDestructor+TypeDestroy end.*/

    /*Apartment start.*/
    $m("Apartment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":2,"n":"buildCam","t":4,"rt":$n[1].Camera,"sn":"buildCam"}]}; }, $n);
    /*Apartment end.*/

    /*Brick start.*/
    $m("Brick", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollisionEnter","t":8,"pi":[{"n":"collision","pt":$n[1].Collision,"ps":0}],"sn":"OnCollisionEnter","rt":$n[0].Void,"p":[$n[1].Collision]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"BrickRigid","t":4,"rt":$n[1].Rigidbody,"sn":"BrickRigid"}]}; }, $n);
    /*Brick end.*/

    /*BrokenBuilding start.*/
    $m("BrokenBuilding", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"BreakingBrick","t":8,"pi":[{"n":"brickList","pt":$n[2].List$1(Brick),"ps":0},{"n":"nameBrick","pt":$n[0].String,"ps":1},{"n":"force","pt":$n[0].Single,"ps":2}],"sn":"BreakingBrick","rt":$n[0].Void,"p":[$n[2].List$1(Brick),$n[0].String,$n[0].Single]},{"a":2,"n":"CheckBrickListHit","t":8,"pi":[{"n":"nameBrick","pt":$n[0].String,"ps":0},{"n":"explodedForce","pt":$n[0].Single,"ps":1}],"sn":"CheckBrickListHit","rt":$n[0].Void,"p":[$n[0].String,$n[0].Single]},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"ScaleBrick","t":8,"pi":[{"n":"brick","pt":Brick,"ps":0},{"n":"randomDelay","pt":$n[0].Single,"ps":1}],"sn":"ScaleBrick","rt":$n[0].Void,"p":[Brick,$n[0].Single]},{"a":2,"n":"IsBreakAll","t":4,"rt":$n[0].Boolean,"sn":"IsBreakAll","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"brickList1","t":4,"rt":$n[2].List$1(Brick),"sn":"brickList1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"brickList2","t":4,"rt":$n[2].List$1(Brick),"sn":"brickList2"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"brickList3","t":4,"rt":$n[2].List$1(Brick),"sn":"brickList3"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"brickList4","t":4,"rt":$n[2].List$1(Brick),"sn":"brickList4"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"brickList5","t":4,"rt":$n[2].List$1(Brick),"sn":"brickList5"}]}; }, $n);
    /*BrokenBuilding end.*/

    /*KameBullet start.*/
    $m("KameBullet", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"X2Pref","t":4,"rt":$n[1].GameObject,"sn":"X2Pref"}]}; }, $n);
    /*KameBullet end.*/

    /*EnemyScript start.*/
    $m("EnemyScript", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Die","t":8,"sn":"Die","rt":$n[0].Void},{"a":1,"n":"OnTriggerEnter","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"dieee","t":8,"sn":"dieee","rt":$n[3].IEnumerator},{"a":1,"n":"enableRagDoll","t":8,"sn":"enableRagDoll","rt":$n[0].Void},{"a":1,"n":"setRagDoll","t":8,"sn":"setRagDoll","rt":$n[0].Void},{"a":2,"n":"RagDollParts","t":4,"rt":$n[2].List$1(UnityEngine.Collider),"sn":"RagDollParts"},{"a":2,"n":"_anim","t":4,"rt":$n[1].Animator,"sn":"_anim"},{"a":2,"n":"_rigid","t":4,"rt":$n[1].Rigidbody,"sn":"_rigid"},{"a":2,"n":"bloodfx","t":4,"rt":$n[1].GameObject,"sn":"bloodfx"},{"a":1,"n":"bulelttrace","t":4,"rt":$n[1].Vector3,"sn":"bulelttrace"},{"a":2,"n":"destination","t":4,"rt":$n[1].Vector3,"sn":"destination"},{"a":2,"n":"impact","t":4,"rt":$n[0].Single,"sn":"impact","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isDead","t":4,"rt":$n[0].Boolean,"sn":"isDead","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"maincollider","t":4,"rt":$n[1].Collider,"sn":"maincollider"},{"a":2,"n":"run","t":4,"rt":$n[4].Tween,"sn":"run"}]}; }, $n);
    /*EnemyScript end.*/

    /*SpawnAttackPos start.*/
    $m("SpawnAttackPos", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*SpawnAttackPos end.*/

    /*AnimatorEventReceiver start.*/
    $m("AnimatorEventReceiver", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Hold","t":8,"sn":"Hold","rt":$n[0].Void},{"a":2,"n":"PlaySoundBulidMagic","t":8,"sn":"PlaySoundBulidMagic","rt":$n[0].Void},{"a":2,"n":"SpawnBullet","t":8,"sn":"SpawnBullet","rt":$n[0].Void},{"a":2,"n":"BuildMagic","t":2,"ad":{"a":2,"n":"add_BuildMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBuildMagic","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BuildMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBuildMagic","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"HoldMagic","t":2,"ad":{"a":2,"n":"add_HoldMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addHoldMagic","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_HoldMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeHoldMagic","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ShootMagic","t":2,"ad":{"a":2,"n":"add_ShootMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addShootMagic","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ShootMagic","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeShootMagic","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*AnimatorEventReceiver end.*/

    /*StyledMonoBehaviour start.*/
    $m("StyledMonoBehaviour", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*StyledMonoBehaviour end.*/

    /*StyledScriptableObject start.*/
    $m("StyledScriptableObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*StyledScriptableObject end.*/

    /*TypeDestroy start.*/
    $m("TypeDestroy", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DESTROY","is":true,"t":4,"rt":TypeDestroy,"sn":"DESTROY","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}},{"a":2,"n":"DISABLE","is":true,"t":4,"rt":TypeDestroy,"sn":"DISABLE","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}},{"a":2,"n":"RESPAWNER","is":true,"t":4,"rt":TypeDestroy,"sn":"RESPAWNER","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}}]}; }, $n);
    /*TypeDestroy end.*/

    /*AutoDestroy start.*/
    $m("AutoDestroy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"timeOut","t":4,"rt":$n[0].Single,"sn":"timeOut","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"timeStart","t":4,"rt":$n[0].Single,"sn":"timeStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"typeDestroy","t":4,"rt":TypeDestroy,"sn":"typeDestroy","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}}]}; }, $n);
    /*AutoDestroy end.*/

    /*BulletCameraController start.*/
    $m("BulletCameraController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CalculateTime","t":8,"sn":"CalculateTime","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"_camMoveTarget","t":4,"rt":$n[1].Vector3,"sn":"_camMoveTarget"},{"a":1,"n":"_camRotationTarget","t":4,"rt":$n[1].Vector3,"sn":"_camRotationTarget"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bulletCam","t":4,"rt":$n[1].Camera,"sn":"bulletCam"},{"a":1,"n":"moveTime","t":4,"rt":$n[0].Single,"sn":"moveTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*BulletCameraController end.*/

    /*CutoutMask start.*/
    $m("CutoutMask", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"materialForRendering","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_materialForRendering","t":8,"rt":$n[1].Material,"fg":"materialForRendering"},"fn":"materialForRendering"}]}; }, $n);
    /*CutoutMask end.*/

    /*GameManager1 start.*/
    $m("GameManager1", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Win","t":8,"sn":"Win","rt":$n[0].Void},{"a":2,"n":"changeCamEndGameLose","t":8,"pi":[{"n":"a","pt":$n[1].Camera,"ps":0}],"sn":"changeCamEndGameLose","rt":$n[0].Void,"p":[$n[1].Camera]},{"a":2,"n":"checkForVictory","t":8,"sn":"checkForVictory","rt":$n[0].Void},{"a":2,"n":"IsShooting","t":4,"rt":$n[0].Boolean,"sn":"IsShooting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SniperGun","t":4,"rt":BaseGun,"sn":"SniperGun"},{"a":2,"n":"_mainCam","t":4,"rt":$n[1].Camera,"sn":"_mainCam"},{"a":2,"n":"backgroundFX","t":4,"rt":$n[1].AudioSource,"sn":"backgroundFX"},{"a":2,"n":"canvasshooting","t":4,"rt":$n[1].GameObject,"sn":"canvasshooting"},{"at":[new UnityEngine.HeaderAttribute("EndCard Stuff")],"a":2,"n":"eclose","t":4,"rt":$n[1].GameObject,"sn":"eclose"},{"a":2,"n":"ecwin","t":4,"rt":$n[1].GameObject,"sn":"ecwin"},{"a":2,"n":"guide","t":4,"rt":$n[1].GameObject,"sn":"guide"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"itsOver","t":4,"rt":$n[0].Boolean,"sn":"itsOver","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"numberofenemy","t":4,"rt":$n[0].Int32,"sn":"numberofenemy","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"player","t":4,"rt":PlayerController,"sn":"player"},{"a":2,"n":"soundfx","t":4,"rt":SoundManager,"sn":"soundfx"}]}; }, $n);
    /*GameManager1 end.*/

    /*GameManager2 start.*/
    $m("GameManager2", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Win","t":8,"sn":"Win","rt":$n[0].Void},{"a":2,"n":"changeCamEndGameLose","t":8,"pi":[{"n":"a","pt":$n[1].Camera,"ps":0}],"sn":"changeCamEndGameLose","rt":$n[0].Void,"p":[$n[1].Camera]},{"a":2,"n":"checkForVictory","t":8,"sn":"checkForVictory","rt":$n[0].Void},{"a":2,"n":"IsShooting","t":4,"rt":$n[0].Boolean,"sn":"IsShooting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RedHeart","t":4,"rt":$n[5].Image,"sn":"RedHeart"},{"a":2,"n":"SniperGun","t":4,"rt":MagicHand,"sn":"SniperGun"},{"a":2,"n":"_mainCam","t":4,"rt":$n[1].Camera,"sn":"_mainCam"},{"a":2,"n":"backgroundFX","t":4,"rt":$n[1].AudioSource,"sn":"backgroundFX"},{"a":2,"n":"canvasshooting","t":4,"rt":$n[1].GameObject,"sn":"canvasshooting"},{"at":[new UnityEngine.HeaderAttribute("EndCard Stuff")],"a":2,"n":"eclose","t":4,"rt":$n[1].GameObject,"sn":"eclose"},{"a":2,"n":"ecwin","t":4,"rt":$n[1].GameObject,"sn":"ecwin"},{"a":2,"n":"guide","t":4,"rt":$n[1].GameObject,"sn":"guide"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"itsOver","t":4,"rt":$n[0].Boolean,"sn":"itsOver","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"numberofenemy","t":4,"rt":$n[0].Int32,"sn":"numberofenemy","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"player","t":4,"rt":PlayerControllerHand,"sn":"player"},{"a":2,"n":"soundfx","t":4,"rt":SoundManager,"sn":"soundfx"}]}; }, $n);
    /*GameManager2 end.*/

    /*IECControl start.*/
    $m("IECControl", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*IECControl end.*/

    /*BaseBullet start.*/
    $m("BaseBullet", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BulletRigid","t":4,"rt":$n[1].Rigidbody,"sn":"BulletRigid"},{"a":2,"n":"Damage","t":4,"rt":$n[0].Single,"sn":"Damage","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DamageForce","t":4,"rt":$n[0].Single,"sn":"DamageForce","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"bloodFx","t":4,"rt":$n[1].ParticleSystem,"sn":"bloodFx"},{"a":2,"n":"exploreFx","t":4,"rt":$n[1].ParticleSystem,"sn":"exploreFx"}]}; }, $n);
    /*BaseBullet end.*/

    /*BaseGun start.*/
    $m("BaseGun", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ExploreFx","t":8,"sn":"ExploreFx","rt":$n[0].Void},{"v":true,"a":2,"n":"Fire","t":8,"sn":"Fire","rt":$n[0].Void},{"a":3,"n":"LoadBullet","t":8,"sn":"LoadBullet","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"Preparing","t":8,"sn":"Preparing","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"IsEnemy","t":4,"rt":$n[0].Boolean,"sn":"IsEnemy","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"bullet","t":4,"rt":BaseBullet,"sn":"bullet"},{"a":2,"n":"bulletObj","t":4,"rt":$n[1].GameObject,"sn":"bulletObj"},{"a":3,"n":"bulletRigid","t":4,"rt":$n[1].Rigidbody,"sn":"bulletRigid"},{"a":2,"n":"fireFx","t":4,"rt":$n[1].ParticleSystem,"sn":"fireFx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"fireFxTrans","t":4,"rt":$n[1].Transform,"sn":"fireFxTrans"},{"a":3,"n":"hit","t":4,"rt":$n[1].RaycastHit,"sn":"hit"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"loadBulletPos","t":4,"rt":$n[1].Vector3,"sn":"loadBulletPos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"loadBulletRot","t":4,"rt":$n[1].Vector3,"sn":"loadBulletRot"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"main","t":4,"rt":$n[1].Camera,"sn":"main"}]}; }, $n);
    /*BaseGun end.*/

    /*BulletRotation start.*/
    $m("BulletRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*BulletRotation end.*/

    /*NormalBullet start.*/
    $m("NormalBullet", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CheckSlowDieLastShot","t":8,"sn":"CheckSlowDieLastShot","rt":$n[0].Void},{"a":1,"n":"Init","t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"OnCollisionEnter","t":8,"pi":[{"n":"collision","pt":$n[1].Collision,"ps":0}],"sn":"OnCollisionEnter","rt":$n[0].Void,"p":[$n[1].Collision]},{"a":1,"n":"OnTriggerEnter","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"_isSLow","t":4,"rt":$n[0].Boolean,"sn":"_isSLow","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bulletList","t":4,"rt":$n[1].GameObject,"sn":"bulletList"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cameraMain","t":4,"rt":$n[1].Camera,"sn":"cameraMain"}]}; }, $n);
    /*NormalBullet end.*/

    /*NormalGun start.*/
    $m("NormalGun", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Fire","t":8,"sn":"Fire","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"shootForce","t":4,"rt":$n[0].Single,"sn":"shootForce","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"x2Pref","t":4,"rt":$n[1].GameObject,"sn":"x2Pref"}]}; }, $n);
    /*NormalGun end.*/

    /*MagicHand start.*/
    $m("MagicHand", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnScoped","t":8,"sn":"OnScoped","rt":$n[0].Void},{"a":2,"n":"Shoot","t":8,"sn":"Shoot","rt":$n[0].Void},{"v":true,"a":2,"n":"SpawnMagicBullet","t":8,"sn":"SpawnMagicBullet","rt":$n[0].Void},{"a":1,"n":"spawnMagic","t":8,"sn":"spawnMagic","rt":$n[3].IEnumerator},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"fireFx","t":4,"rt":$n[1].ParticleSystem,"sn":"fireFx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"handAnimator","t":4,"rt":$n[1].Animator,"sn":"handAnimator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"magicObj","t":4,"rt":$n[1].GameObject,"sn":"magicObj"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"magicSpawnPos","t":4,"rt":$n[1].GameObject,"sn":"magicSpawnPos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"secondFireFx","t":4,"rt":$n[1].ParticleSystem,"sn":"secondFireFx"}]}; }, $n);
    /*MagicHand end.*/

    /*PlayerController start.*/
    $m("PlayerController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampAngle","is":true,"t":8,"pi":[{"n":"angle","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"ClampAngle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"OnDrag","t":8,"pi":[{"n":"evenData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnDrag","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":2,"n":"OnPointerUp","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":1,"n":"OnScoped","t":8,"sn":"OnScoped","rt":$n[0].Void},{"a":1,"n":"OnUnscoped","t":8,"sn":"OnUnscoped","rt":$n[0].Void},{"a":1,"n":"Shooting","t":8,"sn":"Shooting","rt":$n[0].Void},{"a":2,"n":"CanShoot","t":4,"rt":$n[0].Boolean,"sn":"CanShoot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsInteractive","t":4,"rt":$n[0].Boolean,"sn":"IsInteractive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsShooting","t":4,"rt":$n[0].Boolean,"sn":"IsShooting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsShowEnemyPopup","t":4,"rt":$n[0].Boolean,"sn":"IsShowEnemyPopup","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SniperGun","t":4,"rt":BaseGun,"sn":"SniperGun"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_FOVcache","t":4,"rt":$n[0].Single,"sn":"_FOVcache","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_FOVscoped","t":4,"rt":$n[0].Single,"sn":"_FOVscoped","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"downCamBound","t":4,"rt":$n[0].Single,"sn":"downCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gunMovingPos","t":4,"rt":$n[1].Vector3,"sn":"gunMovingPos"},{"a":1,"n":"lastMousePosition","t":4,"rt":$n[1].Vector3,"sn":"lastMousePosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"leftCamBound","t":4,"rt":$n[0].Single,"sn":"leftCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"m_camera","t":4,"rt":$n[1].Camera,"sn":"m_camera"},{"a":1,"n":"m_isClickPoint","t":4,"rt":$n[0].Boolean,"sn":"m_isClickPoint","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_ispointDown","t":4,"rt":$n[0].Boolean,"sn":"m_ispointDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rightCamBound","t":4,"rt":$n[0].Single,"sn":"rightCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scopeOverlay","t":4,"rt":$n[5].Image,"sn":"scopeOverlay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"smoothTime","t":4,"rt":$n[0].Single,"sn":"smoothTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"upCamBound","t":4,"rt":$n[0].Single,"sn":"upCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"velocity","t":4,"rt":$n[0].Single,"sn":"velocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*PlayerController end.*/

    /*PlayerControllerHand start.*/
    $m("PlayerControllerHand", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampAngle","is":true,"t":8,"pi":[{"n":"angle","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"ClampAngle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"OnDrag","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnDrag","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":2,"n":"OnPointerUp","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":1,"n":"OnScoped","t":8,"sn":"OnScoped","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"CanShoot","t":4,"rt":$n[0].Boolean,"sn":"CanShoot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsInteractive","t":4,"rt":$n[0].Boolean,"sn":"IsInteractive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsShooting","t":4,"rt":$n[0].Boolean,"sn":"IsShooting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsShowEnemyPopup","t":4,"rt":$n[0].Boolean,"sn":"IsShowEnemyPopup","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"downCamBound","t":4,"rt":$n[0].Single,"sn":"downCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastMousePosition","t":4,"rt":$n[1].Vector3,"sn":"lastMousePosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"leftCamBound","t":4,"rt":$n[0].Single,"sn":"leftCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_camera","t":4,"rt":$n[1].Camera,"sn":"m_camera"},{"a":1,"n":"m_ispointDown","t":4,"rt":$n[0].Boolean,"sn":"m_ispointDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_ispointUp","t":4,"rt":$n[0].Boolean,"sn":"m_ispointUp","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"magichand","t":4,"rt":MagicHand,"sn":"magichand"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rightCamBound","t":4,"rt":$n[0].Single,"sn":"rightCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"smoothTime","t":4,"rt":$n[0].Single,"sn":"smoothTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"upCamBound","t":4,"rt":$n[0].Single,"sn":"upCamBound","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"velocity","t":4,"rt":$n[0].Single,"sn":"velocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*PlayerControllerHand end.*/

    /*Scope start.*/
    $m("Scope", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scopeImgList","t":4,"rt":$n[2].List$1(UnityEngine.UI.Image),"sn":"scopeImgList"}]}; }, $n);
    /*Scope end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"playgunhitted","t":8,"sn":"playgunhitted","rt":$n[0].Void},{"a":2,"n":"playgunreload","t":8,"sn":"playgunreload","rt":$n[0].Void},{"a":2,"n":"playgunshot","t":8,"sn":"playgunshot","rt":$n[0].Void},{"a":2,"n":"gunfx","t":4,"rt":$n[1].AudioSource,"sn":"gunfx"},{"a":2,"n":"monsterdie","t":4,"rt":$n[1].AudioSource,"sn":"monsterdie"},{"a":2,"n":"reloadfx","t":4,"rt":$n[1].AudioSource,"sn":"reloadfx"}]}; }, $n);
    /*SoundManager end.*/

    /*GlobalInstance start.*/
    $m("GlobalInstance", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"gameManagerInstance","t":4,"rt":GameManager1,"sn":"gameManagerInstance"}]}; }, $n);
    /*GlobalInstance end.*/

    /*SingletonWithouMono$1 start.*/
    $m("SingletonWithouMono$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"Preload","t":8,"sn":"Preload","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"initialized","t":4,"rt":$n[0].Boolean,"sn":"initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"instance","is":true,"t":4,"rt":T,"sn":"instance"}]}; }, $n);
    /*SingletonWithouMono$1 end.*/

    /*SingletonMono$1 start.*/
    $m("SingletonMono$1", function (T) { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":3,"n":"instance","is":true,"t":4,"rt":T,"sn":"instance"}]}; }, $n);
    /*SingletonMono$1 end.*/

    /*Singleton$1 start.*/
    $m("Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"}]}; }, $n);
    /*Singleton$1 end.*/

    /*SingletonDontDestroyOnLoad$1 start.*/
    $m("SingletonDontDestroyOnLoad$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void}]}; }, $n);
    /*SingletonDontDestroyOnLoad$1 end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[7].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[7].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[7].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[7].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[7].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[4].Sequence,"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[9].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[9].Path,$n[0].Single,$n[4].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"towards","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[4].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[8].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[4].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[9].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[9].Path,$n[0].Single,$n[4].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[4].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[8].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[4].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[4].Sequence,"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[1].SpriteRenderer,$n[1].Gradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[4].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[5].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[4].Tweener,"p":[$n[5].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[4].Tweener,"p":[$n[5].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Outline,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Outline,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[5].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[5].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[5].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Image,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[5].Image,$n[1].Gradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[4].Tweener,"p":[$n[5].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[4].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[5].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[4].Tweener,"p":[$n[5].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[5].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Outline,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[5].Outline,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos$1","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[4].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[8].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[5].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[4].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[5].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[5].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[4].Tweener,"p":[$n[5].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[4].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[1].Material,$n[1].Gradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[4].Sequence,"p":[$n[1].Material,$n[1].Gradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[4].DOTweenCYInstruction.WaitForCompletion,$n[4].DOTweenCYInstruction.WaitForRewind,$n[4].DOTweenCYInstruction.WaitForKill,$n[4].DOTweenCYInstruction.WaitForElapsedLoops,$n[4].DOTweenCYInstruction.WaitForPosition,$n[4].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[4].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[4].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[9].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[4].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[9].Path,$n[0].Single,$n[4].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[10].PathOptions,"ps":0},{"n":"t","pt":$n[4].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[10].PathOptions,$n[4].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*Boxophobic.StyledGUI.StyledBanner start.*/
    $m("Boxophobic.StyledGUI.StyledBanner", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"title","pt":$n[0].String,"ps":0}],"sn":"$ctor3"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String],"pi":[{"n":"title","pt":$n[0].String,"ps":0},{"n":"helpURL","pt":$n[0].String,"ps":1}],"sn":"$ctor4"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].String],"pi":[{"n":"title","pt":$n[0].String,"ps":0},{"n":"subtitle","pt":$n[0].String,"ps":1},{"n":"helpURL","pt":$n[0].String,"ps":2}],"sn":"$ctor5"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].String],"pi":[{"n":"colorR","pt":$n[0].Single,"ps":0},{"n":"colorG","pt":$n[0].Single,"ps":1},{"n":"colorB","pt":$n[0].Single,"ps":2},{"n":"title","pt":$n[0].String,"ps":3}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].String,$n[0].String],"pi":[{"n":"colorR","pt":$n[0].Single,"ps":0},{"n":"colorG","pt":$n[0].Single,"ps":1},{"n":"colorB","pt":$n[0].Single,"ps":2},{"n":"title","pt":$n[0].String,"ps":3},{"n":"helpURL","pt":$n[0].String,"ps":4}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].String,$n[0].String,$n[0].String],"pi":[{"n":"colorR","pt":$n[0].Single,"ps":0},{"n":"colorG","pt":$n[0].Single,"ps":1},{"n":"colorB","pt":$n[0].Single,"ps":2},{"n":"title","pt":$n[0].String,"ps":3},{"n":"subtitle","pt":$n[0].String,"ps":4},{"n":"helpURL","pt":$n[0].String,"ps":5}],"sn":"$ctor2"},{"a":2,"n":"colorB","t":4,"rt":$n[0].Single,"sn":"colorB","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"colorG","t":4,"rt":$n[0].Single,"sn":"colorG","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"colorR","t":4,"rt":$n[0].Single,"sn":"colorR","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"helpURL","t":4,"rt":$n[0].String,"sn":"helpURL"},{"a":2,"n":"title","t":4,"rt":$n[0].String,"sn":"title"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledBanner end.*/

    /*Boxophobic.StyledGUI.StyledButton start.*/
    $m("Boxophobic.StyledGUI.StyledButton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"Text","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Single,$n[0].Single],"pi":[{"n":"Text","pt":$n[0].String,"ps":0},{"n":"Top","pt":$n[0].Single,"ps":1},{"n":"Down","pt":$n[0].Single,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Down","t":4,"rt":$n[0].Single,"sn":"down","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Text","t":4,"rt":$n[0].String,"sn":"text"},{"a":2,"n":"Top","t":4,"rt":$n[0].Single,"sn":"top","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledButton end.*/

    /*Boxophobic.StyledGUI.StyledCategory start.*/
    $m("Boxophobic.StyledGUI.StyledCategory", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"category","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Boolean],"pi":[{"n":"category","pt":$n[0].String,"ps":0},{"n":"colapsable","pt":$n[0].Boolean,"ps":1}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Single,$n[0].Single],"pi":[{"n":"category","pt":$n[0].String,"ps":0},{"n":"top","pt":$n[0].Single,"ps":1},{"n":"down","pt":$n[0].Single,"ps":2}],"sn":"$ctor3"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Int32,$n[0].Int32,$n[0].Boolean],"pi":[{"n":"category","pt":$n[0].String,"ps":0},{"n":"top","pt":$n[0].Int32,"ps":1},{"n":"down","pt":$n[0].Int32,"ps":2},{"n":"colapsable","pt":$n[0].Boolean,"ps":3}],"sn":"$ctor2"},{"a":2,"n":"category","t":4,"rt":$n[0].String,"sn":"category"},{"a":2,"n":"colapsable","t":4,"rt":$n[0].Boolean,"sn":"colapsable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"down","t":4,"rt":$n[0].Single,"sn":"down","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"top","t":4,"rt":$n[0].Single,"sn":"top","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledCategory end.*/

    /*Boxophobic.StyledGUI.StyledEnum start.*/
    $m("Boxophobic.StyledGUI.StyledEnum", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Int32,$n[0].Int32],"pi":[{"n":"file","pt":$n[0].String,"ps":0},{"n":"options","pt":$n[0].String,"ps":1},{"n":"top","pt":$n[0].Int32,"ps":2},{"n":"down","pt":$n[0].Int32,"ps":3}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].String,$n[0].Int32,$n[0].Int32],"pi":[{"n":"display","pt":$n[0].String,"ps":0},{"n":"file","pt":$n[0].String,"ps":1},{"n":"options","pt":$n[0].String,"ps":2},{"n":"top","pt":$n[0].Int32,"ps":3},{"n":"down","pt":$n[0].Int32,"ps":4}],"sn":"$ctor1"},{"a":2,"n":"display","t":4,"rt":$n[0].String,"sn":"display"},{"a":2,"n":"down","t":4,"rt":$n[0].Int32,"sn":"down","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"file","t":4,"rt":$n[0].String,"sn":"file"},{"a":2,"n":"options","t":4,"rt":$n[0].String,"sn":"options"},{"a":2,"n":"top","t":4,"rt":$n[0].Int32,"sn":"top","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledEnum end.*/

    /*Boxophobic.StyledGUI.StyledIndent start.*/
    $m("Boxophobic.StyledGUI.StyledIndent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"indent","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"indent","t":4,"rt":$n[0].Int32,"sn":"indent","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledIndent end.*/

    /*Boxophobic.StyledGUI.StyledInteractive start.*/
    $m("Boxophobic.StyledGUI.StyledInteractive", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledInteractive end.*/

    /*Boxophobic.StyledGUI.StyledLayers start.*/
    $m("Boxophobic.StyledGUI.StyledLayers", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"display","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"display","t":4,"rt":$n[0].String,"sn":"display"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledLayers end.*/

    /*Boxophobic.StyledGUI.StyledMask start.*/
    $m("Boxophobic.StyledGUI.StyledMask", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Int32,$n[0].Int32],"pi":[{"n":"file","pt":$n[0].String,"ps":0},{"n":"options","pt":$n[0].String,"ps":1},{"n":"top","pt":$n[0].Int32,"ps":2},{"n":"down","pt":$n[0].Int32,"ps":3}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].String,$n[0].Int32,$n[0].Int32],"pi":[{"n":"display","pt":$n[0].String,"ps":0},{"n":"file","pt":$n[0].String,"ps":1},{"n":"options","pt":$n[0].String,"ps":2},{"n":"top","pt":$n[0].Int32,"ps":3},{"n":"down","pt":$n[0].Int32,"ps":4}],"sn":"$ctor1"},{"a":2,"n":"display","t":4,"rt":$n[0].String,"sn":"display"},{"a":2,"n":"down","t":4,"rt":$n[0].Int32,"sn":"down","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"file","t":4,"rt":$n[0].String,"sn":"file"},{"a":2,"n":"options","t":4,"rt":$n[0].String,"sn":"options"},{"a":2,"n":"top","t":4,"rt":$n[0].Int32,"sn":"top","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledMask end.*/

    /*Boxophobic.StyledGUI.StyledMessage start.*/
    $m("Boxophobic.StyledGUI.StyledMessage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String],"pi":[{"n":"Type","pt":$n[0].String,"ps":0},{"n":"Message","pt":$n[0].String,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Single,$n[0].Single],"pi":[{"n":"Type","pt":$n[0].String,"ps":0},{"n":"Message","pt":$n[0].String,"ps":1},{"n":"Top","pt":$n[0].Single,"ps":2},{"n":"Down","pt":$n[0].Single,"ps":3}],"sn":"$ctor1"},{"a":2,"n":"Down","t":4,"rt":$n[0].Single,"sn":"down","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Message","t":4,"rt":$n[0].String,"sn":"message"},{"a":2,"n":"Top","t":4,"rt":$n[0].Single,"sn":"top","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Type","t":4,"rt":$n[0].String,"sn":"type"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledMessage end.*/

    /*Boxophobic.StyledGUI.StyledRangeOptions start.*/
    $m("Boxophobic.StyledGUI.StyledRangeOptions", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Single,$n[0].Single,$n[0].Array.type(System.String)],"pi":[{"n":"display","pt":$n[0].String,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2},{"n":"options","pt":$n[0].Array.type(System.String),"ps":3}],"sn":"ctor"},{"a":2,"n":"display","t":4,"rt":$n[0].String,"sn":"display"},{"a":2,"n":"max","t":4,"rt":$n[0].Single,"sn":"max","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"min","t":4,"rt":$n[0].Single,"sn":"min","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"options","t":4,"rt":$n[0].Array.type(System.String),"sn":"options"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledRangeOptions end.*/

    /*Boxophobic.StyledGUI.StyledSpace start.*/
    $m("Boxophobic.StyledGUI.StyledSpace", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"space","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"space","t":4,"rt":$n[0].Int32,"sn":"space","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledSpace end.*/

    /*Boxophobic.StyledGUI.StyledText start.*/
    $m("Boxophobic.StyledGUI.StyledText", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[1].TextAnchor],"pi":[{"n":"alignment","pt":$n[1].TextAnchor,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[1].TextAnchor,$n[0].Single,$n[0].Single],"pi":[{"n":"alignment","pt":$n[1].TextAnchor,"ps":0},{"n":"top","pt":$n[0].Single,"ps":1},{"n":"down","pt":$n[0].Single,"ps":2}],"sn":"$ctor2"},{"a":2,"n":"alignment","t":4,"rt":$n[1].TextAnchor,"sn":"alignment","box":function ($v) { return Bridge.box($v, UnityEngine.TextAnchor, System.Enum.toStringFn(UnityEngine.TextAnchor));}},{"a":2,"n":"down","t":4,"rt":$n[0].Single,"sn":"down","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"text","t":4,"rt":$n[0].String,"sn":"text"},{"a":2,"n":"top","t":4,"rt":$n[0].Single,"sn":"top","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledText end.*/

    /*Boxophobic.StyledGUI.StyledTexturePreview start.*/
    $m("Boxophobic.StyledGUI.StyledTexturePreview", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"displayName","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"displayName","t":4,"rt":$n[0].String,"sn":"displayName"}]}; }, $n);
    /*Boxophobic.StyledGUI.StyledTexturePreview end.*/

    /*Boxophobic.Utils.SettingsData start.*/
    $m("Boxophobic.Utils.SettingsData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "Data", menuName: "BOXOPHOBIC/Settings Data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"data","t":4,"rt":$n[0].String,"sn":"data"}]}; }, $n);
    /*Boxophobic.Utils.SettingsData end.*/

});
